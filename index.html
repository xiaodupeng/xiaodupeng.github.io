<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT" />










<meta property="og:type" content="website">
<meta property="og:title" content="欢迎来到我的个人技术分享博客">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="欢迎来到我的个人技术分享博客">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="欢迎来到我的个人技术分享博客">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/"/>





  <title>欢迎来到我的个人技术分享博客</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">欢迎来到我的个人技术分享博客</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/04/27/JavaScript-闭包/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Du Peng">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/dupeng.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="欢迎来到我的个人技术分享博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/04/27/JavaScript-闭包/" itemprop="url">JavaScript 闭包</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-04-27T11:04:50+08:00">
                2018-04-27
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>闭包（closures），在 MDN 解释为：</p>
<blockquote>
<p>Closures are functions that refer to independent (free) variables (variables that are used locally, but defined in an enclosing scope). In other words, these functions ‘remember’ the environment in which they were created.</p>
</blockquote>
<p>闭包是指那些能够访问独立(自由)变量的函数 (变量在本地使用，但定义在一个封闭的作用域中)。换句话说，这些函数可以“记忆”它被创建时候的环境。</p>
<p>闭包是 JavaScript 语言的一个特色，当然也是它的一大难点，很多高级应用都要依靠闭包实现，或者我们平常编码过程中，也在有意无意间使用到闭包。</p>
<h1 id="作用域链"><a href="#作用域链" class="headerlink" title="作用域链"></a>作用域链</h1><p>在理解闭包，首先就要理解 JavaScript 中的作用域链。<br>在 JavaScript 中有两种作用域：全局作用域和函数作用域（在 ES6 中引入了块级作用域）。</p>
<p>在函数中定义的变量只能在本函数体中使用到，在函数外部不能直接调用函数体内部定义的变量，但函数中可以调用到全局作用域中定义的变量。</p>
<p>如果函数中有内嵌函数的定义，则在内嵌函数中可以访问到外部函数中定义的变量，也可访问到全局作用域中的变量，但在外部函数中不能访问内嵌函数中定义的变量。这样，就形成了作用域链，即内嵌函数可调用父级或祖先级函数中定义的变量，但父级函数不能调用子级或后代函数中定义的变量。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">function outer()&#123;</span><br><span class="line">	var outVar = 10;</span><br><span class="line">	function inner()&#123;</span><br><span class="line">		var inVar = 20;</span><br><span class="line">		console.log(&quot;inner 中调用外部函数变量 outVar = &quot; + outVar);</span><br><span class="line">	&#125;</span><br><span class="line">	inner();</span><br><span class="line">	console.log(&quot;outer 中调用内嵌函数变量 inVar = &quot; + inVar);</span><br><span class="line">&#125;</span><br><span class="line">outer();</span><br></pre></td></tr></table></figure></p>
<p>执行结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">inner 中调用外部函数变量 outVar = 10</span><br><span class="line">ReferenceError: Can&apos;t find variable: inVar</span><br></pre></td></tr></table></figure></p>
<p>在 JavaScript 中，变量的作用域是由它在源代码中所处位置决定的，并且嵌套的函数可以访问到其外层作用域中声明的变量。</p>
<h1 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h1><p>如果有这样一种需求，我们需要在外部使用到函数内的变量，但正常情况下，通过直接调用的方式是不能访问到的，这就需要变通的方法了。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">function outer() &#123;</span><br><span class="line">	var i = 1;</span><br><span class="line">	var inner = function()&#123;</span><br><span class="line">		return ++i;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	return inner;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var result = outer();</span><br><span class="line"></span><br><span class="line">console.log(&quot;第一次调用：&quot; + result());</span><br><span class="line">console.log(&quot;第二次调用：&quot; + result());</span><br><span class="line">console.log(&quot;第三次调用：&quot; + result());</span><br></pre></td></tr></table></figure></p>
<p>执行结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">第一次调用：2</span><br><span class="line">第二次调用：3</span><br><span class="line">第三次调用：4</span><br></pre></td></tr></table></figure></p>
<p>上例中，我们要使用到 outer 函数内部的变量 i，每次打印是在原有数值基础上自增 1。因在函数外部不能直接通过变量名对其进行访问，而嵌套在内部的 inner 函数则能够访问到外部函数变量 i，所以返回了内部函数的引用 inner，这样，当 outer 函数调用结束后，放置在 result 中的实际为内嵌函数的引用，这样就可以继续使用到在 outer 函数内部定义的变量 i 了。这就是闭包。</p>
<p>以前常用到的定时器，相信大家写过类似的代码片段：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">function fn()&#123;</span><br><span class="line">	var i = 0;</span><br><span class="line">	var timer = setInterval(function()&#123;</span><br><span class="line">		console.log(i++);</span><br><span class="line">		if(i &gt; 10)</span><br><span class="line">			clearInterval(timer);</span><br><span class="line">	&#125;, 50);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fn();</span><br></pre></td></tr></table></figure></p>
<p>fn 函数调用结束后，按理说在 fn 函数内部的局部变量 i、timer 作用域该结束了，但 setInterval()函数的异步执行过程中，仍然可以使用到这两个变量的值。这也是典型的闭包使用情况。</p>
<h1 id="一个故事"><a href="#一个故事" class="headerlink" title="一个故事"></a>一个故事</h1><p>来解释闭包可以有哪些适用场景前，我喜欢下面这个例子解释。</p>
<p>很久很久以前：</p>
<p>有一位公主……<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">function princess() &#123;</span><br></pre></td></tr></table></figure></p>
<p>她住在一个充满冒险的奇妙世界里，遇到了她的白马王子。白马王子带着她骑着独角兽开始周游世界，与巨龙战斗，巧遇会说话的动物，还有很多其他的不可思议的新奇事物。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var adventures = [];</span><br><span class="line"></span><br><span class="line">    function princeCharming() &#123; /* ... */ &#125;</span><br><span class="line"></span><br><span class="line">    var unicorn = &#123; /* ... */ &#125;,</span><br><span class="line">    	dragons = [ /* ... */ ],</span><br><span class="line">		squirrel = &quot;Hello!&quot;;</span><br></pre></td></tr></table></figure></p>
<p>但她不得不回到自己乏味的王国里，例行去见那些成年人。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">return &#123;</span><br></pre></td></tr></table></figure></p>
<p>她会经常给大人分享她最近作为公主时的充满奇幻的冒险经历。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">sayStory: function() &#123;</span><br><span class="line">			return adventures[adventures.length - 1];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>但在大人的眼里，公主仅仅只是一个小女孩儿……<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var littleGirl = princess();</span><br></pre></td></tr></table></figure></p>
<p>……在讲着一些神奇的、充满幻想的故事。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">littleGirl.sayStory();</span><br></pre></td></tr></table></figure></p>
<p>即便所有大人都知道他们眼前的小女孩是真的公主，但是他们绝不相信有巨龙或独角兽，因为他们自己从来没有见到过。大人们说它们只存在于小女孩的想象之中。</p>
<p>但是我们却知道小女孩述说的是事实……</p>
<h1 id="闭包适用场景"><a href="#闭包适用场景" class="headerlink" title="闭包适用场景"></a>闭包适用场景</h1><p>通常闭包有如下两种适用场景：</p>
<blockquote>
<ul>
<li>在内存中维持变量，如缓存数据</li>
<li>保护函数体内变量的安全，如为对象设置私有属性</li>
</ul>
</blockquote>
<h2 id="缓存数据"><a href="#缓存数据" class="headerlink" title="缓存数据"></a>缓存数据</h2><p>一个比较常用到的例子就是，利用循环为元素绑定事件。</p>
<p>让每个 div 元素被点击时，都能正确弹出当前被点击的 div 的索引：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;div&gt; div-1 &lt;/div&gt;</span><br><span class="line">&lt;div&gt; div-2 &lt;/div&gt;</span><br><span class="line">&lt;div&gt; div-3 &lt;/div&gt;</span><br><span class="line">&lt;div&gt; div-4 &lt;/div&gt;</span><br><span class="line">&lt;div&gt; div-5 &lt;/div&gt;</span><br></pre></td></tr></table></figure></p>
<p>如果使用如下写法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">	function handle()&#123;</span><br><span class="line">		var divs = document.getElementsByTagName(&quot;div&quot;);</span><br><span class="line">		for (var i = 0, len = divs.length; i &lt; len; i++)&#123;</span><br><span class="line">			divs[i].onclick = function()&#123;</span><br><span class="line">				alert(&quot;你点击的 div 索引为：&quot; + i);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	handle();</span><br><span class="line">&lt;/script&gt;	 这时，在每个 div 上点击时弹出的结果都是`你点击的 div 索引为：5`。这是因为事件处理是异步的，但事件绑定是同步的，会先执行完循环体的 5 次操作，为每个 div 绑定上 onclick 事件。</span><br></pre></td></tr></table></figure></p>
<p>这个过程中，变量 i 的值一直在递增变化，当所有 div 元素都被遍历后，i 的值自增到 5 退出循环结构。函数 handle 调用结束后，由于在事件响应程序中仍然存在变量 i 的引用，如果释放变量 i 的资源，会导致事件响应程序执行错误，所以为了保证事件响应程序中仍然能正确使用到变量 i，会将变量 i 的值一直保留在内存中，但保留的 i 的值为 5。</p>
<p>如果要正确输出索引值，可使用闭包修改如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">	function handle()&#123;</span><br><span class="line">		var divs = document.getElementsByTagName(&quot;div&quot;);</span><br><span class="line">		for (var i = 0, len = divs.length; i &lt; len; i++)&#123;</span><br><span class="line">			divs[i].onclick = clk(i);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	function clk(index)&#123;</span><br><span class="line">		return function()&#123;</span><br><span class="line">			alert(&quot;你点击的 div 索引为：&quot; + index);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	handle();</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure></p>
<p>在为每个 div 绑定事件时，调用 clk() 函数将与 div 关联的变量值 i 传递到 clk() 函数内部使用，因为内部返回了一个内嵌函数的引用，该内嵌函数功能的实现依赖于外部函数中的局部变量 index，所以 index 变量的值会在内存中得以缓存。</p>
<p>由于每个 div 绑定事件时，都调用了 clk() 函数来实现事件绑定操作，所以与之对应的变量索引 i 的数值也都在内存中得以缓存，只是这个值不是以 i 的名称来缓存。当我们再次测试时，就可以正确打印出所点击 div 的索引了。</p>
<p>当然以上功能的实现也可以通过自定义属性方式实现：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">	function handle()&#123;</span><br><span class="line">		var divs = document.getElementsByTagName(&quot;div&quot;);</span><br><span class="line">		for (var i = 0, len = divs.length; i &lt; len; i++)&#123;</span><br><span class="line">			divs[i].index = i;</span><br><span class="line">			divs[i].onclick = function()&#123;</span><br><span class="line">				alert(&quot;你点击的 div 索引为：&quot; + this.index);</span><br><span class="line">			&#125;;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	handle();</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure></p>
<p>或是通过 let 命令来实现：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">	function handle()&#123;</span><br><span class="line">		var divs = document.getElementsByTagName(&quot;div&quot;);</span><br><span class="line">		for (let i = 0, len = divs.length; i &lt; len; i++)&#123;</span><br><span class="line">			divs[i].onclick = function()&#123;</span><br><span class="line">				alert(&quot;你点击的 div 索引为：&quot; + i);</span><br><span class="line">			&#125;;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	handle();</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure></p>
<h2 id="为对象设置私有属性"><a href="#为对象设置私有属性" class="headerlink" title="为对象设置私有属性"></a>为对象设置私有属性</h2><p>如果有一个对象，拥有年龄这样一个属性，我们要限定年龄的取值范围在 18~25 岁之间，以类似 Java 面向对象的方式来实现，可模拟如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">	function Student()&#123;</span><br><span class="line">		var age = 18;</span><br><span class="line"></span><br><span class="line">		this.getAge = function()&#123;</span><br><span class="line">			return age;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		this.setAge = function(value) &#123;</span><br><span class="line">			if (value &lt; 18 || value &gt; 25)</span><br><span class="line">				throw new RangeError(&quot;age must between 18 and 25&quot;);</span><br><span class="line">			age = value;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	var stu = new Student();</span><br><span class="line">	console.log(stu.getAge()); // 18</span><br><span class="line">	stu.setAge(36); // 报错：RangeError</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure></p>
<p>age 表示学生的年龄，这样的一个变量如果对于任何人都可以修改值，那么如果给定一个负值，比如 -35，虽然就语法上来说没问题，但就实际逻辑来说，一个人不可能年龄为 -35 岁，所以为了保障这种数据的安全，可以使用闭包来解决。</p>
<p>对 Student 函数内部的局部变量 age 来说，本应该在 Student() 函数通过 new 调用结束后就释放掉资源，但在对象的 getAge/setAge 方法中仍然有对其的引用，释放资源会导致 getAge/setAge 功能不能正常完成，所以其值会保存在内存中。但要修改 age 年龄值时，由于它的作用域问题，我们没法在 Student 函数外直接通过调用 age 的方式来修改，仅能使用提供的 setAge 方法接口修改 age 值，这就保证了对 age 修改赋值的安全性。</p>
<h1 id="一点误解"><a href="#一点误解" class="headerlink" title="一点误解"></a>一点误解</h1><p>以前在查阅资料时，经常见到说不要轻易使用闭包，否则容易造成内存泄漏的说法。</p>
<p>直到看到这篇文章：<a href="http://www.cnblogs.com/rubylouvre/p/3345294.html" target="_blank" rel="noopener">《js闭包测试》</a></p>
<p>闭包里面的变量是我们需要使用到的变量（lives），而内存泄漏通常是指访问不到的变量依然占据内存空间，不能够对其占据的空间再次利用。显然闭包是不属于访问不到的内存空间。</p>
<p>之所以有这样的说法，大概是因为 IE，特别是 IE6 的 bug 吧。当然这是 IE 浏览器的问题，不是闭包的问题。</p>
<p>现代浏览器在 JavaScript 引擎中大都优化处理了闭包情形下的垃圾回收，所以关于内存泄漏的说法，我们大可不必再理会了。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/04/27/浅谈JQuery-ajax-Axios-Fetch区别/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Du Peng">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/dupeng.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="欢迎来到我的个人技术分享博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/04/27/浅谈JQuery-ajax-Axios-Fetch区别/" itemprop="url">浅谈JQuery ajax,Axios,Fetch区别</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-04-27T10:22:32+08:00">
                2018-04-27
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="JQuery-ajax"><a href="#JQuery-ajax" class="headerlink" title="JQuery ajax"></a>JQuery ajax</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$.ajax(&#123;</span><br><span class="line">   type: &apos;POST&apos;,</span><br><span class="line">   url: url,</span><br><span class="line">   data: data,</span><br><span class="line">   dataType: dataType,</span><br><span class="line">   success: function () &#123;&#125;,</span><br><span class="line">   error: function () &#123;&#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>这个我就不用多言了把，是对原生XHR的封装，除此以外还增添了对JSONP的支持。有一说一的说一句，JQuery ajax经过多年的更新维护，真的已经是非常的方便了，优点无需多言；如果是硬要举出几个缺点，那可能只有:</p>
<blockquote>
<ul>
<li>本身是针对MVC的编程,不符合现在前端MVVM的浪潮</li>
<li>基于原生的XHR开发，XHR本身的架构不清晰，已经有了fetch的替代方案</li>
<li>JQuery整个项目太大，单纯使用ajax却要引入整个JQuery非常的不合理（采取个性化打包的方案又不能享受CDN服务）</li>
</ul>
</blockquote>
<p>尽管JQuery对我们前端的开发工作曾有着（现在也仍然有着）深远的影响，但是我们可以看到随着VUE，REACT新一代框架的兴起，以及ES规范的完善，更多API的更新，JQuery这种大而全的JS库，未来的路会越走越窄。</p>
<blockquote>
<p><code>总结：廉颇老矣，尚能饭，但是总有饭不动的一天。</code></p>
</blockquote>
<h1 id="Axios"><a href="#Axios" class="headerlink" title="Axios"></a>Axios</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">axios(&#123;</span><br><span class="line">    method: &apos;post&apos;,</span><br><span class="line">    url: &apos;/user/12345&apos;,</span><br><span class="line">    data: &#123;</span><br><span class="line">        firstName: &apos;Fred&apos;,</span><br><span class="line">        lastName: &apos;Flintstone&apos;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line">.then(function (response) &#123;</span><br><span class="line">    console.log(response);</span><br><span class="line">&#125;)</span><br><span class="line">.catch(function (error) &#123;</span><br><span class="line">    console.log(error);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>Vue2.0之后，尤雨溪推荐大家用axios替换JQuery ajax，想必让Axios进入了很多人的目光中。Axios本质上也是对原生XHR的封装，只不过它是Promise的实现版本，符合最新的ES规范，从它的官网上可以看到它有以下几条特性：</p>
<blockquote>
<ul>
<li>从 node.js 创建 http 请求</li>
<li>支持 Promise API</li>
<li>客户端支持防止CSRF</li>
<li>提供了一些并发请求的接口（重要，方便了很多的操作）</li>
</ul>
</blockquote>
<p>这个支持防止CSRF其实挺好玩的，是怎么做到的呢，就是让你的每个请求都带一个从cookie中拿到的key, 根据浏览器同源策略，假冒的网站是拿不到你cookie中得key的，这样，后台就可以轻松辨别出这个请求是否是用户在假冒网站上的误导输入，从而采取正确的策略。</p>
<p>Axios既提供了并发的封装，也没有下文会提到的fetch的各种问题，而且体积也较小，当之无愧现在最应该选用的请求的方式。</p>
<blockquote>
<p><code>总结：谁敢横刀立马，唯我Axios将军！</code></p>
</blockquote>
<h1 id="Fetch"><a href="#Fetch" class="headerlink" title="Fetch"></a>Fetch</h1><p>fetch号称是AJAX的替代品，它的好处在<a href="https://segmentfault.com/a/1190000003810652" target="_blank" rel="noopener">《传统 Ajax 已死，Fetch 永生》</a>中提到有以下几点：</p>
<blockquote>
<ul>
<li>符合关注分离，没有将输入、输出和用事件来跟踪的状态混杂在一个对象里</li>
<li>更好更方便的写法，诸如：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">try &#123;</span><br><span class="line">  let response = await fetch(url);</span><br><span class="line">  let data = response.json();</span><br><span class="line">  console.log(data);</span><br><span class="line">&#125; catch(e) &#123;</span><br><span class="line">  console.log(&quot;Oops, error&quot;, e);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</blockquote>
<p>坦白说，上面的理由对我来说完全没有什么说服力，因为不管是Jquery还是Axios都已经帮我们把xhr封装的足够好，使用起来也足够方便，为什么我们还要花费大力气去学习fetch？<br>我认为fetch的优势主要优势就是：</p>
<blockquote>
<ul>
<li>更加底层，提供的API丰富（request, response）</li>
<li>脱离了XHR，是ES规范里新的实现方式</li>
</ul>
</blockquote>
<p>大家都喜欢新的东西，坦白说，作为一个前端工程师，我在使用原生XHR的时候，尽管偶尔觉得写的丑陋，但是在使用了JQuery和axios之后，已经对这一块完全无所谓了。当然，如果新的fetch能做的同样好，我为了不掉队也会选择使用fetch。这个道理其实很好理解：你有一架歼8，魔改了N次，性能达到了歼10的水准，但是要是有个人给你拿来一架新的歼10，你也会毫不犹豫的选择新的歼10——不仅仅是新，也代表了还有新的魔改潜力。</p>
<p>但是我最近在使用fetch的时候，也遇到了不少的问题：</p>
<p>fetch是一个低层次的API，你可以把它考虑成原生的XHR，所以使用起来并不是那么舒服，需要进行封装<br>例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1）fetch只对网络请求报错，对400，500都当做成功的请求，需要封装去处理</span><br><span class="line">2）fetch默认不会带cookie，需要添加配置项</span><br><span class="line">3）fetch不支持abort，不支持超时控制，使用setTimeout及Promise.reject的实现的超时控制并不能阻止请求过程继续在后台运行，造成了流量的浪费</span><br><span class="line">4）fetch没有办法原生监测请求的进度，而XHR可以</span><br></pre></td></tr></table></figure></p>
<p>PS: fetch的具体问题大家可以参考:<a href="https://segmentfault.com/a/1190000008484070" target="_blank" rel="noopener">《fetch使用的常见问题及解决方法》</a></p>
<p>看到这里，你心里一定有个疑问，这鬼东西就是个半拉子工程嘛，我还是回去用Jquery或者Axios算了——其实我就是这么打算的。但是，必须要提出的是，我发现fetch在前端的应用上有一项xhr怎么也比不上的能力：跨域的处理。</p>
<p>我们都知道因为同源策略的问题，浏览器的请求是可能随便跨域的——一定要有跨域头或者借助JSONP，但是，fetch中可以设置mode为”no-cors”（不跨域），如下所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">fetch(&apos;/users.json&apos;, &#123;</span><br><span class="line">    method: &apos;post&apos;,</span><br><span class="line">    mode: &apos;no-cors&apos;,</span><br><span class="line">    data: &#123;&#125;</span><br><span class="line">&#125;).then(function() &#123; /* handle response */ &#125;);</span><br></pre></td></tr></table></figure></p>
<p>这样之后我们会得到一个type为“opaque”的返回。需要指出的是，这个请求是真正抵达过后台的，所以我们可以使用这种方法来进行信息上报，在我们之前的image.src方法中多出了一种选择，另外，我们在network中可以看到这个请求后台设置跨域头之后的实际返回，有助于我们提前调试接口（当然，通过chrome插件我们也可以做的到）。总之，fetch现在还不是很好用，我尝试过几个fetch封装的包，都还不尽如人意。</p>
<p>这样之后我们会得到一个type为“opaque”的返回。需要指出的是，这个请求是真正抵达过后台的，所以我们可以使用这种方法来进行信息上报，在我们之前的image.src方法中多出了一种选择，另外，我们在network中可以看到这个请求后台设置跨域头之后的实际返回，有助于我们提前调试接口（当然，通过chrome插件我们也可以做的到）。总之，fetch现在还不是很好用,有待更完善的fetch呈现在世人眼前。</p>
<blockquote>
<p><code>总结：酋长的孩子，还需成长</code></p>
</blockquote>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/04/26/浏览器是如何工作的？/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Du Peng">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/dupeng.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="欢迎来到我的个人技术分享博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/04/26/浏览器是如何工作的？/" itemprop="url">浏览器是如何工作的？</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-04-26T16:49:02+08:00">
                2018-04-26
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="浏览器是如何工作的？"><a href="#浏览器是如何工作的？" class="headerlink" title="浏览器是如何工作的？"></a>浏览器是如何工作的？</h1><h2 id="为什么要了解浏览器是如何工作的"><a href="#为什么要了解浏览器是如何工作的" class="headerlink" title="为什么要了解浏览器是如何工作的"></a>为什么要了解浏览器是如何工作的</h2><p>想要写出一个最佳实践的页面，要实现性能优化，就要好好了解了解浏览器的工作原理。</p>
<blockquote>
<ul>
<li>了解浏览器如何进行加载，可以在引用外部样式表文件、外部 JavaScript 文件时，将他们放到合适的位置，使浏览器以最快的速度及合理的顺序将文件加载完毕。</li>
<li>了解浏览器如何进行解析，可以在构建 DOM 结构，组织 CSS 选择器时，选择最优的写法，提高浏览器的解析效率。</li>
<li>了解浏览器如何进行渲染，明白渲染的过程，在设置元素属性，编写 JavaScript 文件时，可以减少 “reflow” “repaint” 的消耗。</li>
</ul>
</blockquote>
<h2 id="浏览器的主要功能及构成"><a href="#浏览器的主要功能及构成" class="headerlink" title="浏览器的主要功能及构成"></a>浏览器的主要功能及构成</h2><p><strong>浏览器的主要功能</strong> 是将用户选择的 web 资源呈现出来，它需要从服务器请求资源，并将其显示在浏览器窗口中，资源的格式通常是 HTML，也包括 PDF、image 及其他格式。用户用 URI（Uniform Resource Identifier 统一资源标识符）来指定所请求资源的位置。</p>
<p><strong>浏览器的主要构成</strong><br>浏览器的主要组件包括：<br>1.用户界面 － 包括地址栏、后退/前进按钮、书签目录等，也就是你所看到的除了用来显示你所请求页面的主窗口之外的其他部分。<br>2.浏览器引擎 － 用来查询及操作渲染引擎的接口。<br>3.渲染引擎 － 用来显示请求的内容，例如，如果请求内容为 html，它负责解析 html 及 css，并将解析后的结果显示出来。<br>4.网络 － 用来完成网络调用，例如 http 请求，它具有平台无关的接口，可以在不同平台上工作。<br>5.UI 后端 － 用来绘制类似组合选择框及对话框等基本组件，具有不特定于某个平台的通用接口，底层使用操作系统的用户接口。<br>6.JS 解释器 － 用来解释执行 JS 代码。<br>7.数据存储 － 属于持久层，浏览器需要在硬盘中保存类似 cookie 的各种数据，HTML5 定义了 web database 技术，这是一种轻量级完整的客户端存储技术。</p>
<p><img src="/2018/04/26/浏览器是如何工作的？/1.png" alt="logo"></p>
<h1 id="浏览器的渲染"><a href="#浏览器的渲染" class="headerlink" title="浏览器的渲染"></a>浏览器的渲染</h1><h2 id="渲染引擎简介"><a href="#渲染引擎简介" class="headerlink" title="渲染引擎简介"></a>渲染引擎简介</h2><p>渲染引擎的职责就是渲染，即在浏览器窗口中显示所请求的内容。</p>
<p>默认情况下，渲染引擎可以显示 html、xml 文档及图片，它也可以借助插件（一种浏览器扩展）显示其他类型数据，例如使用 PDF 阅读器插件，可以显示 PDF 格式，这里先不讨论插件及扩展，只讨论渲染引擎最主要的用途——显示应用了 CSS 之后的 html 及图片。</p>
<h2 id="渲染流程"><a href="#渲染流程" class="headerlink" title="渲染流程"></a>渲染流程</h2><p><img src="/2018/04/26/浏览器是如何工作的？/2.png" alt="logo"><br>渲染引擎首先通过网络获得所请求文档的内容，通常以 8K 分块的方式完成，即以 8K 每块下载 html 页面。</p>
<p>然后解析页面生成 DOM 树，遇到 CSS 标签或 JS 脚本标签就新起线程去下载他们，并继续构建 DOM。</p>
<p>CSS 下载完后解析为 CSS 规则树，浏览器结合 CSS 规则树和 DOM 树生成 Render Tree。Render Tree 由一些包含有颜色和大小等属性的矩形组成，它们将被按照正确的顺序显示到屏幕上。</p>
<p>JavaScript 下载后可以通过 DOM API 修改 DOM，通过 CSSOM(CSS Object Model) API 修改样式作用域 Render Tree。注意：构建 CSSOM 会阻塞 JavaScript 的执行，JavaScript 的执行也会阻塞 DOM 的构建。</p>
<p>每次修改会造成 Render Tree 的重新布局和重绘。只要修改 DOM 或修改了元素的形状或大小，就会触发 Reflow，单纯修改元素的颜色只需 Repaint 一下（调用操作系统 Native GUI 的 API 绘制）。</p>
<p>Render Tree 构建好了之后，将会执行布局过程，它将确定每个节点在屏幕上的确切坐标。再下一步就是绘制，即遍历 Render Tree，并使用 UI 后端层绘制每个节点。也可用下图描述：<br><img src="/2018/04/26/浏览器是如何工作的？/3.png" alt="logo"><br>值得注意的是，这个过程是逐步完成的，为了更好的用户体验，渲染引擎将会尽可能早的将内容呈现到屏幕上，并不会等到所有的 html 都解析完成之后再去构建和布局 Render Tree。它是解析完一部分内容就显示一部分内容，同时，可能还在通过网络下载其余内容。</p>
<h2 id="reflow-与-repaint"><a href="#reflow-与-repaint" class="headerlink" title="reflow 与 repaint"></a>reflow 与 repaint</h2><ol>
<li>用户输入网址（假设是个 html 页面，并且是第一次访问），浏览器向服务器发出请求，服务器返回 html 文件；</li>
<li>浏览器开始载入 html 代码，发现 <code>&lt;head&gt;</code> 标签内有一个 <code>&lt;link&gt;</code>标签引用外部 CSS 文件；</li>
<li>浏览器发出 CSS 文件的请求，服务器返回这个 CSS 文件；</li>
<li>浏览器继续载入 html 中 <code>&lt;body&gt;</code> 部分的代码，并且 CSS 文件已经拿到手了，可以开始渲染页面了；</li>
<li>浏览器在代码中发现一个 <code>&lt;img&gt;</code>标签引用了一张图片，向服务器发出请求。此时浏览器不会等到图片下载完，而是继续渲染后面的代码；</li>
<li>服务器返回图片文件，由于图片占用了一定面积，影响了后面段落的排布，因此浏览器需要回过头来重新渲染这部分代码；</li>
<li>浏览器发现了一个包含一行 JavaScript 代码的 <code>&lt;script&gt;</code> 标签，赶快运行它；</li>
<li>JavaScript 脚本执行了这条语句，它命令浏览器隐藏掉代码中的某个 <code>&lt;div&gt; （style.display=”none”）</code>。杯具啊，突然就少了这么一个元素，浏览器不得不重新渲染这部分代码；</li>
<li>终于等到了 <code>&lt;/html&gt;</code> 的到来，浏览器泪流满面……</li>
<li>等等，还没完，用户点了一下界面中的“换肤”按钮，JavaScript 让浏览器换了一下 <code>&lt;link&gt;</code> 标签的 CSS 路径；</li>
<li>浏览器召集了在座的各位 <code>&lt;div&gt;&lt;span&gt;&lt;ul&gt;&lt;li&gt;</code> 们，“大伙儿收拾收拾行李，咱得重新来过……”，浏览器向服务器请求了新的 CSS 文件，重新渲染页面。</li>
</ol>
<p>页面为什么会慢？那是因为浏览器要花时间、花精力去渲染，尤其是当它发现某个部分发生了点变化影响了布局，需要倒回去重新渲染，我们称这个回退的过程叫 reflow。</p>
<p>reflow 几乎是无法避免的。现在常见的一些效果，比如树状目录的折叠、展开（实质上是元素的显示与隐藏）等，都将引起浏览器的 reflow。鼠标滑过、点击等，只要这些行为引起了页面上某些元素的占位面积、定位方式、边距等属性的变化，都会引起它内部、周围甚至整个页面的重新渲染。通常我们都无法预估浏览器到底会 reflow 哪一部分的代码，它们都彼此相互影响着。</p>
<p><img src="/2018/04/26/浏览器是如何工作的？/4.jpg" alt="logo"><br>与 reflow 有个看上去差不多的术语叫 repaint (重绘)，如果只是改变了某个元素的背景颜色，文字颜色等，不影响元素周围或内部布局的属性，将只会引起浏览器的 repaint，重画某一部分。<br><img src="/2018/04/26/浏览器是如何工作的？/5.jpg" alt="logo"></p>
<h2 id="引起-repaint-和-reflow-的一些操作"><a href="#引起-repaint-和-reflow-的一些操作" class="headerlink" title="引起 repaint 和 reflow 的一些操作"></a>引起 repaint 和 reflow 的一些操作</h2><p>DOM Tree 里的每个结点都会有 reflow 方法，一个结点的 reflow 很有可能导致子结点，甚至父点以及同级结点的 reflow。在一些高性能的电脑上也许还没什么，但是如果 reflow 发生在手机上，那么这个过程是非常痛苦和耗电的。</p>
<p>所以，下面这些动作有很大可能会是成本比较高的:</p>
<blockquote>
<ul>
<li>当你增加、删除、修改 DOM 结点时；</li>
<li>当你移动 DOM 的位置，或是搞个动画的时候；</li>
<li>当你修改 CSS 样式的时候；</li>
<li>当你 Resize 窗口的时候（移动端没有这个问题），或是滚动的时候；</li>
<li>当你修改网页的默认字体时；</li>
</ul>
</blockquote>
<p>注：display:none 会触发 reflow，而 visibility:hidden 只会触发 repaint，因为没有发现位置变化。</p>
<h2 id="reflow-优化"><a href="#reflow-优化" class="headerlink" title="reflow 优化"></a>reflow 优化</h2><p>reflow 是不可避免的，只能将 reflow 对性能的影响减到最小,给出下面几条建议：</p>
<p><strong>1.</strong> 不要一条一条地修改 DOM 的样式。与其这样，还不如预先定义好 css 的 class，然后修改 DOM 的 className：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// 不好的写法</span><br><span class="line">var left = 10,</span><br><span class="line">	top = 10;</span><br><span class="line">elem.style.left = left + &quot;px&quot;;</span><br><span class="line">elem.style.top  = top  + &quot;px&quot;;</span><br><span class="line">// 推荐写法</span><br><span class="line">elem.className += &quot; classname&quot;;</span><br></pre></td></tr></table></figure></p>
<p><strong>2.</strong> 把 DOM 离线后修改。如</p>
<blockquote>
<ul>
<li>使用 DocumentFragment 对象在内存里操作 DOM。</li>
<li>先把 DOM 给 display:none (有一次 reflow)，然后你想怎么改就怎么改。比如修改 100 次，然后再把他显示出来。</li>
<li>clone 一个 DOM 节点到内存里，然后想怎么改就怎么改，改完后，和在线的那个的交换一下。</li>
</ul>
</blockquote>
<p><strong>3.</strong> 不要把 DOM 节点的属性值放在一个循环里当成循环里的变量。不然这会导致大量地读写这个结点的属性。</p>
<p><strong>4.</strong> 尽可能的修改层级比较低的 DOM节点。当然，改变层级比较低的 DOM节点有可能会造成大面积的 reflow，但是也可能影响范围很小。</p>
<p><strong>5.</strong> 为动画的 HTML 元件使用 fixed 或 absoult 的 position，那么修改他们的 CSS 是会大大减小 reflow 。</p>
<p><strong>6.</strong> 千万不要使用 table 布局。因为可能很小的一个小改动会造成整个 table 的重新布局。<br>reflow 要比 repaint 更花费时间，因为 reflow 也会引发 repaint，也就更影响性能。所以在写代码的时候，要尽量避免过多的 reflow。</p>
<p>以上这些仅是对浏览器工作原理的一个简单说明，大家如果对它感兴趣，可以继续搜索相关文章深入学习，因为我觉得理解浏览器的原理是很重要的，可以帮助我们写出性能更好的页面。</p>
<p>参考：</p>
<p><strong><a href="http://taligarsiel.com/Projects/howbrowserswork1.htm" target="_blank" rel="noopener">http://taligarsiel.com/Projects/howbrowserswork1.htm</a></strong></p>
<p><strong><a href="https://segmentfault.com/a/1190000002629708" target="_blank" rel="noopener">https://segmentfault.com/a/1190000002629708</a></strong></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/04/26/sass使用教程/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Du Peng">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/dupeng.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="欢迎来到我的个人技术分享博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/04/26/sass使用教程/" itemprop="url">sass使用教程</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-04-26T15:35:52+08:00">
                2018-04-26
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>以前我们在写 CSS 时，通常都是直接在外部 CSS 文件中一个属性一个属性的敲，如果要实现代码的复用，那就 ctrl+c 和 ctrl+v 了，如果要使用某个 RGB 颜色值，还得一遍遍的翻回去复制。这样的开发效率很低，并且也很烦琐，因为 CSS 并不是编程语言，所以也就不能像写 JavaScript 代码一样来实现流程控制等操作了。</p>
<p>幸运的是现在我们有了“CSS预处理器”（css preprocessor），在 CSS 中加入了编程元素，当然不是直接使用 CSS 来实现编程，而是使用专门的编程语言，进行设计后再编译成 CSS 文件。<br><img src="/2018/04/26/sass使用教程/sass_logo.png" alt="logo"></p>
<h1 id="SASS-安装与使用"><a href="#SASS-安装与使用" class="headerlink" title="SASS 安装与使用"></a>SASS 安装与使用</h1><p><img src="/2018/04/26/sass使用教程/sass.png" alt="logo"></p>
<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>要使用 SASS 首先需要安装 SASS 环境，可参见：<a href="http://sass-lang.com/install。" target="_blank" rel="noopener">http://sass-lang.com/install。</a></p>
<p>SASS 是基于 Ruby 语言写的，所以必须先安装 Ruby，但是 SASS 与 Ruby 的语法没有关系，即使完全不懂 Ruby，也可以使用 SASS。</p>
<p>windows 系统中安装 Ruby 最快速的方式是使用 RubyInstaller。RubyInstaller 也会自动安装命令行工具让我们可以直接使用它的库。</p>
<p>Ruby 安装好后，打开命令提示符（win+r 运行框中输入 cmd 回车即可），输入以下命令：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gem install sass</span><br></pre></td></tr></table></figure></p>
<p>即可安装 SASS，但安装有时也会被墙，所以可以直接下载 SASS 的 gem 库离线安装，下载地址为：<a href="https://api.rubygems.org/gems/sass-3.4.22.gem。" target="_blank" rel="noopener">https://api.rubygems.org/gems/sass-3.4.22.gem。</a></p>
<p>下载后在命令提示符下直接安装：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gem install d:/sass-3.4.22.gem</span><br></pre></td></tr></table></figure></p>
<p>当然我们前边也安装了 Gulp 插件 gulp-sass，可以借助 Gulp 来实现 SASS 编译，也不用安装 Ruby。详情见 《Gulp 使用教程》。</p>
<h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p>SASS 文件就是普通的文本文件，可以直接使用 CSS 语法，文件后缀名是 .scss（3.0以前的版本通常使用 .sass 后缀）。</p>
<p>如果安装了 Ruby 环境和 SASS，则可以在命令提示符下输入：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sass style.scss</span><br></pre></td></tr></table></figure></p>
<p>会直接在屏幕上显示出 .scss 文件转换为 .css 文件后的样式内容。也可以继续跟上输出文件的路径名，将编译后的 CSS 内容保存到文件中：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sass style.scss style.css</span><br></pre></td></tr></table></figure></p>
<p>在编译成 CSS 时，SASS 提供四种编译风格：</p>
<blockquote>
<ul>
<li>nested —- 嵌套缩进</li>
<li>expanded —- 没有缩进，扩展的</li>
<li>compact —- 简洁格式</li>
<li>compressed —- 压缩</li>
</ul>
</blockquote>
<p>默认是使用 nested 风格，在生产环境当中，一般使用最后一个（compressed）。</p>
<p>也可以让 SASS 监听某个文件或目录的修改，自动生成编译后的版本：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sass --watch style.scss:style.css</span><br></pre></td></tr></table></figure></p>
<p>或<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sass --watch app/sass:public/stylesheets</span><br></pre></td></tr></table></figure></p>
<p>如果没有安装 Ruby 环境而是使用 Gulp 插件，可参见 <a href="https://github.com/dlmanning/gulp-sass" target="_blank" rel="noopener">https://github.com/dlmanning/gulp-sass</a> 的使用。<br>如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var gulp = require(&quot;gulp&quot;),</span><br><span class="line">	sass = require(&quot;gulp-sass&quot;);</span><br><span class="line"></span><br><span class="line">gulp.task(&quot;sass&quot;, function()&#123;</span><br><span class="line">	gulp.src(&quot;scss/*.scss&quot;)</span><br><span class="line">		.pipe(sass(&#123;outputStyle:&quot;compact&quot;&#125;))</span><br><span class="line">		.pipe(gulp.dest(&quot;dist/css&quot;));</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<h1 id="SASS-基本语法"><a href="#SASS-基本语法" class="headerlink" title="SASS 基本语法"></a>SASS 基本语法</h1><h2 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h2><p>SASS 中有三种注释：<br><strong>单行注释</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">// 单行注释</span><br></pre></td></tr></table></figure></p>
<p>在输出 CSS 文件时不保留该注释内容。<br><strong>多行注释</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line"> * 多行注释内容</span><br><span class="line"> * 作者：小杜</span><br><span class="line"> */</span><br></pre></td></tr></table></figure></p>
<p>在编译输出的非压缩格式的 CSS 文件中会保留，压缩输出格式中不会保留。<br><strong>强制注释</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">/*!</span><br><span class="line">* 强制注释内容</span><br><span class="line">*/</span><br></pre></td></tr></table></figure></p>
<p>表示强制保留注释内容，不管输出什么格式。</p>
<h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><p>SASS 中的所有变量都是以 $ 开头，后紧跟变量名称，变量名与变量值之间以冒号（:）分隔开：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">$width : 180px;</span><br><span class="line">$bgColor : #eaeaea;</span><br><span class="line"></span><br><span class="line">.container &#123;</span><br><span class="line">	width: $width;</span><br><span class="line">	background-color: $bgColor;</span><br><span class="line">	height: 360px;</span><br><span class="line">	border:1px solid;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.box &#123;</span><br><span class="line">	width: $width;</span><br><span class="line">	height:230px;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.cube &#123;</span><br><span class="line">	background-color: $bgColor;</span><br><span class="line">	border: 1px solid;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>生成的 CSS 文件为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">.container &#123; width: 180px; background-color: #eaeaea; height: 360px; border: 1px solid; &#125;</span><br><span class="line"></span><br><span class="line">.box &#123; width: 180px; height: 230px; &#125;</span><br><span class="line"></span><br><span class="line">.cube &#123; background-color: #eaeaea; border: 1px solid; &#125;</span><br></pre></td></tr></table></figure></p>
<p>如果变量需要镶嵌在字符串之中，需要写在 #{} 之中，如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$l : left;</span><br><span class="line">$r : right;</span><br><span class="line"></span><br><span class="line">.box &#123;</span><br><span class="line">	margin-#&#123;$l&#125;: 30px;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.container &#123;</span><br><span class="line">	margin-#&#123;$r&#125;: 20px;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>生成的 CSS 文件为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">.box &#123; margin-left: 30px; &#125;</span><br><span class="line">.container &#123; margin-right: 20px; &#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="嵌套"><a href="#嵌套" class="headerlink" title="嵌套"></a>嵌套</h2><p><strong>选择器嵌套</strong><br>scss 文件：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">#container &#123;</span><br><span class="line">	.title &#123;</span><br><span class="line">		width:300px;</span><br><span class="line">		height:200px;</span><br><span class="line">		border:1px solid #ccc;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	.main_body&#123;</span><br><span class="line">		width:250px;</span><br><span class="line">		height:350px;</span><br><span class="line">		border:1px solid #ccc;</span><br><span class="line">		border-radius:5px;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>超级链接伪类样式的设计，SASS 中可以通过 &amp; 符号引用父属性：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">a &#123;</span><br><span class="line">	&amp;:link &#123;</span><br><span class="line">		text-decoration: none;</span><br><span class="line">		color: black;</span><br><span class="line">	&#125;</span><br><span class="line">	&amp;:visited &#123;</span><br><span class="line">		text-decoration: none;</span><br><span class="line">		color: black;</span><br><span class="line">	&#125;</span><br><span class="line">	&amp;:hover &#123;</span><br><span class="line">		text-decoration: underline;</span><br><span class="line">		color: red;</span><br><span class="line">	&#125;</span><br><span class="line">	&amp;:active &#123;</span><br><span class="line">		text-decoration: underline;</span><br><span class="line">		color: gray;</span><br><span class="line">		font-size: 18px;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>属性嵌套</strong><br>scss 文件：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">#container &#123;</span><br><span class="line">	background: &#123;</span><br><span class="line">		color : #ccc;</span><br><span class="line">		image : url(imgs/001.png);</span><br><span class="line">		position: top left;</span><br><span class="line">		repeat: no-repeat;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>属性嵌套使用得相对较少一些。</p>
<h2 id="代码重用"><a href="#代码重用" class="headerlink" title="代码重用"></a>代码重用</h2><p><strong>Mixin 混合</strong><br>Mixin 类似于宏命令，可以实现代码块重用，使用 @mixin 命令定义代码块：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">@mixin left-block &#123;</span><br><span class="line">	width: 360px;</span><br><span class="line">	line-height: 30px;</span><br><span class="line">	background: #ccc;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.left_side_nav &#123;</span><br><span class="line">	@include left-block;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.left_side_fav &#123;</span><br><span class="line">	@include left-block;</span><br><span class="line">	color : red;</span><br><span class="line">	font-size: 12px;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>使用 @include 命令复用代码块。</p>
<p>@mixin 可以使用参数与默认值：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">@mixin left-block($width:300px) &#123;</span><br><span class="line">	width: $width;</span><br><span class="line">	line-height: 30px;</span><br><span class="line">	background: #ccc;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.left_side_nav &#123;</span><br><span class="line">	@include left-block(200px);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.left_side_fav &#123;</span><br><span class="line">	@include left-block;</span><br><span class="line">	color : red;</span><br><span class="line">	font-size: 12px;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>当使用 @include 调用代码块复用时，如果不使用默认值，则直接传递实际值即可，如果不传递值，则使用默认值，上述示例编译成 CSS：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.left_side_nav &#123; width: 200px; line-height: 30px; background: #ccc; &#125;</span><br><span class="line"></span><br><span class="line">.left_side_fav &#123; width: 300px; line-height: 30px; background: #ccc; color: red; font-size: 12px; &#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>extend 继承/扩展</strong><br>也可使用继承/扩展来减少重复代码实现代码重用，可以让一个选择器去继承另一个选择中所有的样式，使用命令 @extend：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">.left-block &#123;</span><br><span class="line">	width: 300px;</span><br><span class="line">	line-height: 30px;</span><br><span class="line">	background: #ccc;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.left_side_nav &#123;</span><br><span class="line">	@extend .left-block;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.left_side_fav &#123;</span><br><span class="line">	@extend .left-block;</span><br><span class="line">	color : red;</span><br><span class="line">	font-size: 12px;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>import 导入</strong><br>可使用 @import 命令导入外部文件，外部文件可以是 .scss 文件，也可以是 .css 文件，但当导入 .css 文件时，相当于是 CSS 中的 @import 命令：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@import &apos;plugin.scss&apos;;</span><br><span class="line">@import &apos;../css/style.css&apos;;</span><br><span class="line"></span><br><span class="line">.cube &#123;</span><br><span class="line">	color:red;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>生成的 CSS：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@import url(../css/style.css);</span><br><span class="line">.box &#123; width: 300px; height: 200px; background: #ccc; &#125;</span><br><span class="line"></span><br><span class="line">.cube &#123; color: red; &#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="流程控制指令"><a href="#流程控制指令" class="headerlink" title="流程控制指令"></a>流程控制指令</h1><p><strong>@if</strong><br>条件控制指令，类似于 JavaScript 中的简单 if 结构，即当 if 条件满足时执行指定的表达式，语法结构为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">@if 条件 &#123;</span><br><span class="line">	// 条件为真时执行的样式</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>当然有 @if 就有配套的 @else，与 JavaScript 中的 if-else 是一个道理：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@if 条件 &#123;</span><br><span class="line">	// 条件为真时执行的样式</span><br><span class="line">&#125; @else &#123;</span><br><span class="line">	// 条件为假时执行的样式</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>示例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$width : 360px;</span><br><span class="line"></span><br><span class="line">.container &#123;</span><br><span class="line">	@if $width / 3 &gt; 100 &#123;</span><br><span class="line">		border: 1px solid;</span><br><span class="line">		padding: 10px;</span><br><span class="line">	&#125; @else &#123;</span><br><span class="line">		border:5px solid;</span><br><span class="line">		padding:20px;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>@for</strong><br>循环控制指令，类似于 JavaScript 中的 for 循环结构。语法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">@for $var from &lt;start&gt; to &lt;end&gt; &#123;</span><br><span class="line">	// 循环体</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>示例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">@for $var from 1 to 10 &#123;</span><br><span class="line">	.m-#&#123;$var&#125; &#123;margin: #&#123;$var&#125;px;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>生成 .m-1、.m-2 …… .m-10 10个样式。<br><strong>@while</strong><br>类似于 JavaScript 中的 while 循环，语法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">@while 条件 &#123;</span><br><span class="line">	// 循环体</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>示例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$i : 10;</span><br><span class="line"></span><br><span class="line">@while $i &gt; 0 &#123;</span><br><span class="line">	.p-#&#123;$i&#125; &#123;padding: #&#123;$i&#125;px&#125;;</span><br><span class="line">	$i : $i - 2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>@each</strong><br>@each 与 @for 类似，语法结构为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@each $var in &lt;list&gt;</span><br></pre></td></tr></table></figure></p>
<p>@each 常用于列表或映射数据的循环，示例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$list : info warning debug error;</span><br><span class="line"></span><br><span class="line">@each $var in $list &#123;</span><br><span class="line">	.icon-#&#123;$var&#125; &#123;</span><br><span class="line">		background-image:url(imgs/#&#123;$var&#125;.png);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h1><p>函数的功能主要是数据的运算，SASS 中可以将一些值交给函数进行处理，具体的处理方式由定义的函数具体的设计确定。</p>
<p>自定义函数的语法结构为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">@function 函数名称(参数列表)&#123;</span><br><span class="line">	// 数据处理</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>示例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$colors : (light:#fff, dark:#000, gray:#ccc);</span><br><span class="line"></span><br><span class="line">@function color($name) &#123;</span><br><span class="line">	@return map-get($colors, $name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.container &#123;</span><br><span class="line">	background-color: color(gray);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><code>map-get($colors, $name)</code>的作用是获取 $colors 中名称为 $name 的值，变量 $colors 是一个 map 集合，保存的是名值对。</p>
<h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>本文将 SASS 使用过程中常用用法做了简单的总结，日常开发一般就不需要再去查官方文档了，如果有更深层次的使用或对某个用法不熟悉，也可查询官方文档，详情见：<a href="http://sass-lang.com/documentation/file.SASS_REFERENCE.html。" target="_blank" rel="noopener">http://sass-lang.com/documentation/file.SASS_REFERENCE.html。</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/04/12/git使用教程/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Du Peng">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/dupeng.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="欢迎来到我的个人技术分享博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/04/12/git使用教程/" itemprop="url">git使用教程</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-04-12T17:28:23+08:00">
                2018-04-12
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="一、什么是-Git"><a href="#一、什么是-Git" class="headerlink" title="一、什么是 Git"></a>一、什么是 Git</h1><p>Git 是 Linus Torvalds 为了帮助管理 Linux 内核开发而开发的一个开放源码的版本控制软件。</p>
<p>Git 是一个开源的分布式版本控制系统，用于敏捷高效的处理任何项目的版本问题。与常用的版本控制工具 CVS、SVN 等不同，Git 采用了分布式版本库的方式，不必服务器端软件支持。可以说 Git 是目前世界上最先进的分布式版本控制系统。</p>
<h1 id="二、关于项目版本管理"><a href="#二、关于项目版本管理" class="headerlink" title="二、关于项目版本管理"></a>二、关于项目版本管理</h1><p>项目在开发的过程中，经常会出现多人分工协作进行项目开发并整合的过程，所以经常会出现一些协作开发时同步的问题，同时存在项目整体进度的控制和管理的问题，所以在程序开发行业衍生出来了版本管理工具。</p>
<p>版本管理工具，首先是一个内容管理工具，可以将项目的内容信息存放在版本管理服务器上方便项目组人员进行访问和查询修改。</p>
<p>版本管理具有里程碑意义的主要有三个阶段：CVS 阶段 –&gt; SVN 阶段 –&gt; Git 阶段。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CVS 阶段</span><br></pre></td></tr></table></figure>
<p><img src="/2018/04/12/git使用教程/cvs.png" alt="logo"></p>
<p>项目搭建开发过程中，每次提交项目都会将整个项目提交到服务器进行保存，服务器存储着项目的 N 个备份，开发过程中的协作效率较低，同时也出现了各种传输的问题，所以慢慢淡出了行业。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SVN 阶段</span><br></pre></td></tr></table></figure>
<p><img src="/2018/04/12/git使用教程/svn.png" alt="logo"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Git 阶段</span><br></pre></td></tr></table></figure>
<p><img src="/2018/04/12/git使用教程/git.png" alt="logo"></p>
<p>CVS 和 SVN 都是基于一个服务器的，如果脱离服务器，项目的版本保存就没有了任何意义，Git 恰恰处理了这样的问题。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Git 与 SVN 区别</span><br></pre></td></tr></table></figure>
<h2 id="1-Git-是分布式的，而-SVN-不是"><a href="#1-Git-是分布式的，而-SVN-不是" class="headerlink" title="1. Git 是分布式的，而 SVN 不是"></a>1. Git 是分布式的，而 SVN 不是</h2><p>SVN 是集中式版本控制系统，版本库是集中放在中央服务器的。通常我们干活的时候，用的都是自己的电脑，所以首先要从中央服务器哪里得到最新的版本，然后开始干活，活干完后，需要把自己做完的活推送到中央服务器。集中式版本控制系统是必须联网才能工作，如果在局域网还可以，带宽够大，速度够快，如果在互联网下，加上网速慢的话，就纳闷了。</p>
<p>Git 是分布式版本控制系统，这是和其它非分布式的版本控制系统（SVN，CVS）最核心的区别。如果你能理解这个概念，那么你就已经上手一半了。</p>
<p>Git 跟 SVN 一样有自己的集中式版本库或服务器。但 Git 更倾向于被使用于分布式模式，也就是每个开发人员从中心版本库的服务器上 chect out 代码后会在自己的机器上克隆一个自己的版本库。可以这样说，如果你被困在一个不能连接网络的地方时，比如在飞机上，地下室，电梯里，通信欠发达的地区等，你仍然能够提交文件，查看历史版本记录，创建项目分支等。因为每个人的电脑就是一个完整的版本库，这样，工作的时候就不需要联网了，版本都是在自己的电脑上。对一些人来说，这好像没多大用处，但当你突然遇到没有网络的环境时，这个将解决你的大麻烦。</p>
<h2 id="2-Git-按照元数据的方式存储内容，SVN-是按照文件的形式存储"><a href="#2-Git-按照元数据的方式存储内容，SVN-是按照文件的形式存储" class="headerlink" title="2. Git 按照元数据的方式存储内容，SVN 是按照文件的形式存储"></a>2. Git 按照元数据的方式存储内容，SVN 是按照文件的形式存储</h2><p>所有的资源控制系统都是把文件的元信息隐藏在一个类似 .cvs、.svn、.git 的目录里。如果你把 .git 目录的体积大小跟 .svn 比较，你会发现它们差距很大。因为 .git 目录是你机器上的一个克隆版的版本库，它拥有中心版本库上所有的东西，例如标签、分支、版本记录等。</p>
<h2 id="3-Git-和-SVN-中的分支不同"><a href="#3-Git-和-SVN-中的分支不同" class="headerlink" title="3. Git 和 SVN 中的分支不同"></a>3. Git 和 SVN 中的分支不同</h2><p>分支在 SVN 中一点不特别，就是版本库中的另外的一个目录。如果你想知道是否合并了一个分支，你需要手工运行命令来确认代码是否被合并。所以，经常会发生有些分支被遗漏的情况。</p>
<p>然而，处理 Git 的分支却是相当的简单和有趣，你可以从同一个工作目录下快速的在几个分支间切换。你很容易发现未被合并的分支，你能简单而快捷的合并这些文件。</p>
<h2 id="4-Git-没有全局版本号，SVN-有"><a href="#4-Git-没有全局版本号，SVN-有" class="headerlink" title="4. Git 没有全局版本号，SVN 有"></a>4. Git 没有全局版本号，SVN 有</h2><p>目前为止这是跟 SVN 相比 Git 缺少的最大的一个特征。SVN的版本号实际是任何一个相应时间的源代码快照，它是从 CVS 进化到 SVN 的最大的一个突破。Git 可以使用 SHA-1 来唯一的标识一个代码快照，但这个并不能完全的代替 SVN 里容易阅读的数字版本号。</p>
<h2 id="5-Git-内容的完整性优于-SVN"><a href="#5-Git-内容的完整性优于-SVN" class="headerlink" title="5. Git 内容的完整性优于 SVN"></a>5. Git 内容的完整性优于 SVN</h2><p>Git 的内容存储使用的是 SHA-1 哈希算法，这能确保代码内容的完整性，确保在遇到磁盘故障和网络问题时降低对版本库的破坏。</p>
<h1 id="三、Git-安装与配置"><a href="#三、Git-安装与配置" class="headerlink" title="三、Git 安装与配置"></a>三、Git 安装与配置</h1><h2 id="1-安装"><a href="#1-安装" class="headerlink" title="1.安装"></a>1.安装</h2><p>以 windows 操作系统为例，以下操作均在 windows 7 32 bit 系统环境下进行。<br>在使用 Git 之前，我们需要安装 Git，下载地址：<a href="http://git-scm.com/downloads" target="_blank" rel="noopener">http://git-scm.com/downloads</a><br><img src="/2018/04/12/git使用教程/download.png" alt="logo"><br>选择 windows 操作平台（如果是其它系统对应选择即可）下载对应的安装包。<br><img src="/2018/04/12/git使用教程/download_git.png" alt="logo"><br>双击安装包开始安装，一路点击 “Next” 下一步即可，我在选择组件时将快捷方式添加到了桌面，以方便使用，当然不做任何修改全部使用默认推荐到最后安装完成也可。<br><img src="/2018/04/12/git使用教程/git_components.png" alt="logo"><br>安装完成后，在桌面可见到 Git Bash 的快捷方式，或是在开始菜单中可以找到 Git 文件夹：<br><img src="/2018/04/12/git使用教程/git_bash.png" alt="logo"><br>或<br><img src="/2018/04/12/git使用教程/git_start.png" alt="logo"></p>
<h2 id="2-配置"><a href="#2-配置" class="headerlink" title="2.配置"></a>2.配置</h2><p>一般在新的系统上，我们都需要先配置下自己的 Git 工作环境。配置工作只需一次，以后升级时还会沿用现在的配置。当然，如果需要，你随时可以用相同的命令修改已有的配置。<br>在 Windows 系统上，Git 会找寻用户主目录下的 .gitconfig 文件。主目录即 $HOME 变量指定的目录，一般都是 C:\Users\$USER。<br><strong>用户信息</strong><br>第一个要配置的是你个人的用户名称和电子邮件地址。这两条配置很重要，每次 Git 提交时都会引用这两条信息，说明是谁提交了更新，所以会随更新内容一起被永久纳入历史记录：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git config --global user.name &quot;username&quot;</span><br><span class="line">$ git config --global user.email xxx@xxx.xx</span><br></pre></td></tr></table></figure></p>
<p><img src="/2018/04/12/git使用教程/config_username.png" alt="logo"><br>若使用 git config 时用 –global 选项，读写的就是用户主目录下的 .gitconfig 文件。<br><strong>查看配置信息</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git config --list</span><br></pre></td></tr></table></figure></p>
<p><img src="/2018/04/12/git使用教程/git_list.png" alt="logo"></p>
<h1 id="四、Git-工作区、暂存区、版本库"><a href="#四、Git-工作区、暂存区、版本库" class="headerlink" title="四、Git 工作区、暂存区、版本库"></a>四、Git 工作区、暂存区、版本库</h1><ul>
<li><strong>工作区:</strong> 就是你在电脑里能看到的目录。</li>
<li><strong>暂存区:</strong> 英文叫 stage，或 index。一般存放在 “.git” 目录下的 index 文件（.git/index）中，所以我们把暂存区有时也叫作索引（index）。</li>
<li><strong>版本库:</strong> 工作区有一个隐藏目录 .git，这个不算工作区，而是 Git 的版本库。<br><img src="/2018/04/12/git使用教程/repository.png" alt="logo"></li>
</ul>
<p>上图左侧为工作区，右侧为版本库。在版本库中标记为 “index” 的区域是暂存区（stage, index），标记为 “master” 的是 master 分支所代表的目录树。</p>
<p>从图中我们可以看出此时 “HEAD” 实际是指向 master 分支的一个”游标”。所以图示的命令中出现 HEAD 的地方可以用 master 来替换。</p>
<p>图中的 objects 标识的区域为 Git 的对象库，实际位于 “.git/objects” 目录下，里面包含了创建的各种对象及内容。</p>
<p>当对工作区修改（或新增）的文件执行 “git add” 命令时，暂存区的目录树被更新，同时工作区修改（或新增）的文件内容被写入到对象库中的一个新的对象中，而该对象的ID被记录在暂存区的文件索引中。</p>
<p>当执行提交操作（git commit）时，暂存区的目录树写到版本库（对象库）中，master 分支会做相应的更新。即 master 指向的目录树就是提交时暂存区的目录树。</p>
<p>当执行 “git reset HEAD” 命令时，暂存区的目录树会被重写，被 master 分支指向的目录树所替换，但是工作区不受影响。</p>
<p>当执行 “git rm –cached “ 命令时，会直接从暂存区删除文件，工作区则不做出改变。</p>
<p>当执行 “git checkout .” 或者 “git checkout – “ 命令时，会用暂存区全部或指定的文件替换工作区的文件。这个操作很危险，会清除工作区中未添加到暂存区的改动。</p>
<p>当执行 “git checkout HEAD .” 或者 “git checkout HEAD “ 命令时，会用 HEAD 指向的 master 分支中的全部或者部分文件替换暂存区和以及工作区中的文件。这个命令也是极具危险性的，因为不但会清除工作区中未提交的改动，也会清除暂存区中未提交的改动。</p>
<h1 id="五、Git-工作流程"><a href="#五、Git-工作流程" class="headerlink" title="五、Git 工作流程"></a>五、Git 工作流程</h1><p><img src="/2018/04/12/git使用教程/work_flow.png" alt="logo"><br>一般工作流程如下：</p>
<ul>
<li>克隆 Git 资源作为工作目录。</li>
<li>在克隆的资源上添加或修改文件。</li>
<li>如果其他人修改了，你可以更新资源。</li>
<li>在提交前查看修改。</li>
<li>提交修改。</li>
<li>在修改完成后，如果发现错误，可以撤回提交并再次修改并提交。</li>
</ul>
<h1 id="六、Git-基本操作"><a href="#六、Git-基本操作" class="headerlink" title="六、Git 基本操作"></a>六、Git 基本操作</h1><h2 id="1-创建仓库"><a href="#1-创建仓库" class="headerlink" title="1. 创建仓库"></a>1. 创建仓库</h2><p>版本库又叫仓库，英文名：repository，你可以简单的理解为一个目录，这个目录里面的所有文件都可以被 Git 管理起来，每个文件的修改，删除，Git 都能跟踪，以便任何时刻都可以追踪历史，或者在将来某个时刻还可以将文件“还原”。<br>有两种取得 Git 仓库的方法，第一种是在现在的目录下，通过导入所有文件来创建新的 Git 仓库，第二种是从已有的 Git 仓库中克隆出一个新的镜像仓库来。<br>下面我们先使用第一种方式创建 Git 仓库（第二种创建仓库的方式稍后讲解）。</p>
<h3 id="1-初始化仓库"><a href="#1-初始化仓库" class="headerlink" title="1. 初始化仓库"></a>1. 初始化仓库</h3><p>我先在 F: 盘下创建了一个目录（git_test，相当于我们的工作区），从 Git Bash 中进入该目录，执行如下命令：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git init</span><br></pre></td></tr></table></figure></p>
<p>初始化后，在当前目录下会出现一个名为 .git 的隐藏目录，这个目录是 Git 来跟踪管理版本的，所有 Git 需要的数据和资源都存放在这个目录中，所以没事千万不要手动乱改这个目录里面的文件，否则可能会把 Git 仓库给破坏了。<br><img src="/2018/04/12/git使用教程/git_init.png" alt="logo"><br>生成的隐藏目录：<br><img src="/2018/04/12/git使用教程/git_init_folder.png" alt="logo"></p>
<h3 id="2-将文件添加到仓库中"><a href="#2-将文件添加到仓库中" class="headerlink" title="2. 将文件添加到仓库中"></a>2. 将文件添加到仓库中</h3><p>在 git_test 目录下新建一个文本文件 readme.txt，内容为：version 1.0.1.10161117_beta<br><strong>跟踪文件</strong><br>使用如下命令跟踪文件：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git add 文件/目录路径</span><br></pre></td></tr></table></figure></p>
<p>在 git add 后面可以指明要跟踪的文件或目录路径。如果是目录的话，就说明要递归跟踪该目录下的所有文件。其实 git add 的潜台词就是把目标文件快照放入暂存区域，也就是 add file into staged area，同时未曾跟踪过的文件标记为需要跟踪。这样就好理解后续 add 操作的实际意义了。<br><img src="/2018/04/12/git使用教程/add_readme.png" alt="logo"><br>如果和上面一样，没有任何提示，说明已经添加成功了。</p>
<p>我们可以使用 cat 命令查看文件内容：<br><img src="/2018/04/12/git使用教程/cat_readme.png" alt="logo"><br><strong>提交到版本库</strong><br>我们先使用 git status 来查看状态信息：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git status</span><br></pre></td></tr></table></figure></p>
<p>再使用命令 git commit 告诉 Git，把文件提交到仓库：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git commit -m &apos;info&apos;</span><br></pre></td></tr></table></figure></p>
<p><img src="/2018/04/12/git使用教程/git_commit.png" alt="logo"><br>从上图中 git status 可以看出，readme.txt 文件已被跟踪，并处于暂存状态。只要在 “Changes to be committed:” 这行下面的，就说明是已暂存状态。如果此时提交，那么该文件此时此刻的版本将被留存在历史记录中。</p>
<h2 id="2-修改文件"><a href="#2-修改文件" class="headerlink" title="2. 修改文件"></a>2. 修改文件</h2><p><strong>暂存已修改文件</strong><br>现在我们修改下之前已跟踪过的文件 readme.txt，在头部插入一行：version 1.0.2，然后再次运行 git status 命令，会看到这样的状态报告：<br><img src="/2018/04/12/git使用教程/modify_not_add.png" alt="logo"><br>这说明已跟踪文件的内容发生了变化（readme.txt 文件已被修改），但还没有放到暂存区。要暂存这次更新，需要运行 git add 命令（这是个多功能命令，根据目标文件的状态不同，此命令的效果也不同：可以用它开始跟踪新文件，或者把已跟踪的文件放到暂存区，还能用于合并时把有冲突的文件标记为已解决状态等）。</p>
<p>使用 git add 将 readme.txt 添加到暂存区，状态：<br>这说明已跟踪文件的内容发生了变化（readme.txt 文件已被修改），但还没有放到暂存区。要暂存这次更新，需要运行 git add 命令（这是个多功能命令，根据目标文件的状态不同，此命令的效果也不同：可以用它开始跟踪新文件，或者把已跟踪的文件放到暂存区，还能用于合并时把有冲突的文件标记为已解决状态等）。</p>
<p>使用 git add 将 readme.txt 添加到暂存区，状态：<br><img src="/2018/04/12/git使用教程/modify_add.png" alt="logo"><br>现在 readme.txt 已暂存，下一次 commit 提交时就会记录到仓库。假设此时，我们修改 readme.txt，继续在头部插入一行：version 1.0.3，保存后，又会是什么情况呢？<br><img src="/2018/04/12/git使用教程/modify_add_2.png" alt="logo"><br>从上图中我们可以看到，readme.txt 文件出现了两次，一次是已暂存，一次是未暂存，这是怎么回事呢？</p>
<p>实际上 Git 只不过暂存了你运行 git add 命令时的版本，如果现在提交，那么提交的是添加 “version 1.0.3” 前的版本，而非当前工作目录中的版本。所以，运行了 git add 之后又作了修改的文件，需要重新运行 git add 把最新版本重新暂存起来：<br><img src="/2018/04/12/git使用教程/modify_add.png" alt="logo"><br><strong>查看已暂存和未暂存的更新</strong><br>实际上 git status 的显示比较简单，仅仅是列出了修改过的文件，如果要查看具体修改了什么地方，可以用 git diff 命令。现在，我们来解决两个问题：当前做的哪些更新还没有暂存，有哪些更新已经暂存起来准备好了下次提交？ git diff 会使用文件补丁的格式显示具体添加和删除的行。</p>
<p>我们将 readme.txt 文件中的 “version 1.0.3” 修改为 “version 1.0.3_beta”，然后继续在头部插入一行 “version 1.0.4”，查看状态：<br><img src="/2018/04/12/git使用教程/modify_add_2.png" alt="logo"><br>要查看尚未暂存的文件了更新了哪些内容，使用 git diff：<br><img src="/2018/04/12/git使用教程/diff_not_staged.png" alt="logo"><br>此命令比较的是工作目录中当前文件和暂存区域快照之间的差异，也就是修改之后还没有暂存起来的变化内容。</p>
<p>若要看已经暂存起来的文件和上次提交时的快照之间的差异，可以用 git diff –staged 命令。来看看实际的效果：<br><img src="/2018/04/12/git使用教程/diff_staged.png" alt="logo"><br>注意，git diff 不跟参数是显示还没有暂存起来的改动，而不是这次工作和上次提交之间的差异。<br>我们将刚做的修改提交到版本库中。在此之前，一定要确认还有什么修改过的或新建的文件还没有 git add 过，否则提交的时候不会记录这些还没暂存起来的变化。所以，每次准备提交前，先用 git status 看下，是不是都已暂存起来了，然后再运行提交命令 git commit：<br><img src="/2018/04/12/git使用教程/modify_commit.png" alt="logo"></p>
<h2 id="3-撤销修改和删除文件"><a href="#3-撤销修改和删除文件" class="headerlink" title="3. 撤销修改和删除文件"></a>3. 撤销修改和删除文件</h2><h3 id="1-撤销修改"><a href="#1-撤销修改" class="headerlink" title="1. 撤销修改"></a>1. 撤销修改</h3><p>我现在在 readme.txt 文件里面头部插入一行内容为：version 1.0.5，我们先查看一下：<br><img src="/2018/04/12/git使用教程/modify_add_3.png" alt="logo"><br>在未提交之前，如果发现添加的内容有误，得马上恢复以前的版本，现在我可以有如下几种方法可以做修改：</p>
<p>第一：如果我知道要删掉那些内容的话，直接手动更改去掉那些需要的文件，然后 git add 添加到暂存区，最后 commit。</p>
<p>第二：使用 git reset –hard HEAD^ 回退到上一个版本（稍后讲解）。</p>
<p>第三：通过上图我们可以看到提示使用 git checkout – <file>… 来丢弃已做的修改。<br><img src="/2018/04/12/git使用教程/git_checkout.png" alt="logo"><br>命令 git checkout – readme.txt 意思就是，把readme.txt文件在工作区做的修改全部撤销。</file></p>
<p>但对于 readme.txt 的修改也可能存在以下两种情况：</p>
<p>一种情况是：readme.txt 修改后，还没有放到暂存区，使用撤销修改就回到和版本库一模一样的状态，上图显示的就是这种情况。</p>
<p>另外一种是 readme.txt 已经放入暂存区，接着再一次作了修改，撤销修改就回到添加暂存区后的状态，如下所示：<br><img src="/2018/04/12/git使用教程/git_checkout_2.png" alt="logo"><br>再作一次修改：<br><img src="/2018/04/12/git使用教程/git_checkout_3.png" alt="logo"><br>撤销修改后：<br><img src="/2018/04/12/git使用教程/git_checkout_4.png" alt="logo"><br>我们可以看到，撤销修改回到的状态是将 readme.txt 添加到暂存区后的状态。</p>
<h3 id="2-删除文件"><a href="#2-删除文件" class="headerlink" title="2.删除文件"></a>2.删除文件</h3><p>现在我们在工作区添加一个文件 profile.txt，然后提交。如下所示：<br><img src="/2018/04/12/git使用教程/add_profile.png" alt="logo"><br>这时，我们发现刚添加的文件有错误，需要删除。</p>
<p>一般情况下，我们直接在工作区将刚添加的 profile.txt 文件删除，但当我们再使用 git status 时，情况如下：<br><img src="/2018/04/12/git使用教程/delete_file.png" alt="logo"><br>此时有两个选择，一个是使用 git add/rm <file>… 删除后再提交保存到版本库，一个是撤销删除操作。</file></p>
<p>提交保存到版本库：<br><img src="/2018/04/12/git使用教程/git_add_rm.png" alt="logo"><br>或<br><img src="/2018/04/12/git使用教程/git_add_rm_2.png" alt="logo"><br>使用 git add/rm <file>… 是将状态存入暂存区，然后使用 git commit -m ‘info’ 提交保存到版本库中。</file></p>
<p>使用 git checkout – <file>… 撤销删除的操作：<br><img src="/2018/04/12/git使用教程/git_add_rm_3.png" alt="logo"><br>需要注意的是，当不是通过直接在工作区删除文件，而是通过 git rm <file>… 删除了工作区文件，需要通过版本回退的方式撤销删除动作。</file></file></p>
<h2 id="4-版本回退"><a href="#4-版本回退" class="headerlink" title="4. 版本回退"></a>4. 版本回退</h2><h3 id="1-查看提交历史"><a href="#1-查看提交历史" class="headerlink" title="1. 查看提交历史"></a>1. 查看提交历史</h3><p>在提交了若干更新之后，又或者克隆了某个项目，想回顾下提交历史，可以使用 git log 命令查看。<br><img src="/2018/04/12/git使用教程/git_log.png" alt="logo"><br>默认不用任何参数的话，git log 会按提交时间列出所有的更新，最近的更新排在最上面。每次更新都有一个 SHA-1 校验和、作者的名字和电子邮件地址、提交时间，最后缩进显示提交说明。</p>
<p>git log 有个常用的 –pretty 选项，可以指定使用完全不同于默认格式的方式展示提交历史。比如用 oneline 将每个提交放在一行显示，这在提交数很大时非常有用。<br><img src="/2018/04/12/git使用教程/git_log_pretty_oneline.png" alt="logo"></p>
<h3 id="2-回退"><a href="#2-回退" class="headerlink" title="2. 回退"></a>2. 回退</h3><p>为方便演示，我再多次修改并提交版本库。<br><img src="/2018/04/12/git使用教程/modify_add_more.png" alt="logo"><br>现在我想使用版本回退操作，把当前的版本回退到上一个版本，使用命令：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git reset --hard HEAD^</span><br></pre></td></tr></table></figure></p>
<p>该命令的作用是重置当前分支的 HEAD 为指定的 HEAD^（HEAD^ 表示当前版本的上一个版本，也可以用 HEAD^^ 表示上上一个版本，以此类推），同时重置暂存区和工作区，与指定的 HEAD^ 一致。<br><img src="/2018/04/12/git使用教程/reset_head.png" alt="logo"><br>那如果再向前回退4个版本的话，使用上面的方法肯定不方便，我们可以使用下面的简便命令操作：git reset –hard HEAD~4 即可：<br><img src="/2018/04/12/git使用教程/reset_head_4.png" alt="logo"><br>使用 git log 查看日志：<br><img src="/2018/04/12/git使用教程/git_log_reset.png" alt="logo"><br>可以看到，现在版本为最初始化的第一个版本信息。</p>
<p>现在又有一个问题出现了，如果我在版本回退时发现现在回退到的这个版本不是我所需要的，而是需要回退到 version 1.0.4 所在的版本，又该怎么办呢？</p>
<p>git log 不能察看已经删除了的 commit 记录，git reflog 则可以查看所有分支的所有操作记录（包括 commit 和 reset 的操作），包括已经被删除的 commit 记录。<br><img src="/2018/04/12/git使用教程/git_reflog.png" alt="logo"><br>最前边一列是对应各版本的版本号，我们可以通过版本号来实现回退：<br><img src="/2018/04/12/git使用教程/git_reset_version.png" alt="logo"><br>现在我们再查看，readme.txt 文件中的内容就为我们需要回退到的版本内容了。</p>
<h1 id="七、分支管理"><a href="#七、分支管理" class="headerlink" title="七、分支管理"></a>七、分支管理</h1><p>几乎每一种版本控制系统都以某种形式支持分支。使用分支意味着你可以从开发主线上分离开来，然后在不影响主线的同时继续工作。在很多版本控制系统中，这是个昂贵的过程，常常需要创建一个源代码目录的完整副本，对大型项目来说会花费很长时间。</p>
<p>有人把 Git 的分支模型称为“必杀技特性”，而正是因为它，将 Git 从版本控制系统家族里区分出来。Git 有何特别之处呢？Git 的分支可谓是难以置信的轻量级，它的新建操作几乎可以在瞬间完成，并且在不同分支间切换起来也差不多一样快。和许多其他版本控制系统不同，Git 鼓励在工作流程中频繁使用分支与合并，哪怕一天之内进行许多次都没有关系。理解分支的概念并熟练运用后，你才会意识到为什么 Git 是一个如此强大而独特的工具，并从此真正改变你的开发方式。</p>
<p>在前边的图片中，我们基本都可以看到这样的内容：<br><img src="/2018/04/12/git使用教程/default_master.png" alt="logo"><br>这是每次操作所在的分支说明，master 分支是默认分支。</p>
<h2 id="1-新建与合并分支"><a href="#1-新建与合并分支" class="headerlink" title="1.新建与合并分支"></a>1.新建与合并分支</h2><p>实际工作中（比如开发一个网站）大概会是这样的工作流程：<br>1.为实现某个新的需求，创建一个分支。<br>2.在这个分支上开展工作。</p>
<p>假设此时，你突然接到一个电话说有个很严重的 bug 需要紧急修复，那么可以接着按照下面的步骤处理：<br>1.返回到原先已经发布到生产服务器上的分支。<br>2.为这次紧急修复建立一个新分支，并在其中修复问题。<br>3.通过测试后，回到生产服务器所在的分支，将修复分支合并进来，然后再推送到生产服务器上。<br>4.切换到之前实现新需求的分支，继续工作。</p>
<h3 id="1-新建分支"><a href="#1-新建分支" class="headerlink" title="1. 新建分支"></a>1. 新建分支</h3><p><strong>创建分支</strong><br>使用如下命令来创建分支：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git branch branch_name</span><br></pre></td></tr></table></figure></p>
<p><img src="/2018/04/12/git使用教程/git_branch_dev.png" alt="logo"></p>
<p><strong>切换分支</strong><br>我们已经创建了一个新分支：dev，但当前分支仍然为 master 分支，所以还需要使用切换分支命令来切换操作：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout branch_name</span><br></pre></td></tr></table></figure></p>
<p><img src="/2018/04/12/git使用教程/git_branch_checkout.png" alt="logo"><br>已成功切换到 dev 分支了。</p>
<p><strong>创建并切换分支</strong><br>我们也可以使用如下命令来新建并切换分支：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout -b branch_name</span><br></pre></td></tr></table></figure></p>
<p><img src="/2018/04/12/git使用教程/git_branch_checkout_bug.png" alt="logo"></p>
<p><strong>列出分支</strong><br>使用命令：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git branch</span><br></pre></td></tr></table></figure></p>
<p><img src="/2018/04/12/git使用教程/git_branch.png" alt="logo"></p>
<p><strong>向分支提交版本库</strong><br>下面我们向新分支 dev 中添加一个文件：<br><img src="/2018/04/12/git使用教程/add_index_to_dev.png" alt="logo"><br>我们来看一下工作区目录结构：<br><img src="/2018/04/12/git使用教程/dev_folder.png" alt="logo"><br>接下来切换回 master 分支：<br><img src="/2018/04/12/git使用教程/git_checkout_master.png" alt="logo"><br>再看一下工作区目录结构：<br><img src="/2018/04/12/git使用教程/master_folder.png" alt="logo"><br>比较两个不同分支下的目录结构，我们可以发现，在 dev 分支下保存到版本库中的文件 index.html，在 master 分支下看不见了。这是因为当切换分支的时候，Git 会用该分支的最后提交的快照替换工作目录的内容。</p>
<h3 id="2-合并分支"><a href="#2-合并分支" class="headerlink" title="2.合并分支"></a>2.合并分支</h3><p>如果我们需要将在 dev 分支版本库中的内容也添加到 master 分支中来，则需要合并分支：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git merge</span><br></pre></td></tr></table></figure></p>
<p><img src="/2018/04/12/git使用教程/git_merge.png" alt="logo"><br>合并后工作区目录结构：<br><img src="/2018/04/12/git使用教程/dev_folder.png" alt="logo"><br>当然，合并并不仅仅是简单的文件添加、移除的操作，Git 也会合并修改。</p>
<p><strong>合并冲突</strong><br>首先在 master 分支下新建一个文本文件 site.txt 并提交，如下所示：<br><img src="/2018/04/12/git使用教程/add_site.png" alt="logo"><br>创建一个新分支 dev，在新分支中修改 site.txt 并提交，如下所示：<br><img src="/2018/04/12/git使用教程/modify_site.png" alt="logo"><br>切换回 master 分支，再查看 site.txt 文件内容：<br><img src="/2018/04/12/git使用教程/git_checkout_master_2.png" alt="logo"><br>当前 master 分支中没有未提交的修改，我们继续在 master 分支中修改 site.txt，向文件末尾添加一行 “<a href="http://www.codingke.com/”" target="_blank" rel="noopener">http://www.codingke.com/”</a> 的内容：<br><img src="/2018/04/12/git使用教程/modify_site_2.png" alt="logo"><br>接下来，把 dev 分支中的内容合并过来：<br><img src="/2018/04/12/git使用教程/git_merge_2.png" alt="logo"><br>这时，一个合并冲突就出现了，我们需要手动修改冲突，修改完毕后：<br><img src="/2018/04/12/git使用教程/git_merge_conflict.png" alt="logo"><br>确保冲突合并修改完毕后，提交到版本库中：<br><img src="/2018/04/12/git使用教程/git_merge_conflict_fixed.png" alt="logo"></p>
<h3 id="3-删除分支"><a href="#3-删除分支" class="headerlink" title="3.删除分支"></a>3.删除分支</h3><p>合并完成后，我们可以接着删除dev分支了，命令：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git branch -d branch_name</span><br></pre></td></tr></table></figure></p>
<p>如：<br><img src="/2018/04/12/git使用教程/git_branch_del.png" alt="logo"></p>
<h1 id="八、Git-远程仓库"><a href="#八、Git-远程仓库" class="headerlink" title="八、Git 远程仓库"></a>八、Git 远程仓库</h1><p>Git 并不像 SVN 那样有个中心服务器。目前我们使用到的 Git 命令都是在本地执行，如果你想通过 Git 分享你的代码或者与其他开发人员合作。你就需要将数据放到一台其他开发人员能够连接的服务器上。</p>
<p>以下的介绍使用了 GitHub 作为远程仓库。</p>
<h2 id="1-GitHub-简介"><a href="#1-GitHub-简介" class="headerlink" title="1. GitHub 简介"></a>1. GitHub 简介</h2><p>如果你是一枚 Coder，但是你不知道 GitHub，那么我觉的你就不是一个菜鸟级别的 Coder，因为你压根不是真正 Coder，你只是一个 Code 搬运工。—- 菜鸟教程如是说。</p>
<p>GitHub是一个通过Git进行版本控制的软件源代码托管服务，由GitHub公司（曾称Logical Awesome）的开发者Chris Wanstrath、PJ Hyett和Tom Preston-Werner使用Ruby on Rails编写而成。</p>
<p>GitHub同时提供付费账户和免费账户。这两种账户都可以创建公开的代码仓库，但是付费账户也可以创建私有的代码仓库。根据在2009年的Git用户调查，GitHub是最流行的Git访问站点。除了允许个人和组织创建和访问代码库以外，它也提供了一些方便社会化软件开发的功能，包括允许用户追踪其他用户、组织、软件库的动态，对软件代码的改动和bug提出评论等。GitHub也提供了图表功能，用于显示开发者们怎样在代码库上工作以及软件的开发活跃程度。</p>
<p>截止到2015年，GitHub已经有超过九百万注册用户和2110万代码库。事实上已经成为了世界上最大的代码存放网站和开源社区。<br>我们先作为免费用户来使用一下 GitHub。免费用户只能使用公共仓库，也就是代码要公开。</p>
<h2 id="2-注册账户"><a href="#2-注册账户" class="headerlink" title="2. 注册账户"></a>2. 注册账户</h2><p>要想使用 GitHub，第一步当然是注册 GitHub 账号了。如果你已经注册过 GitHub 账号，请跳过这一步。GitHub 官网地址：<a href="https://github.com/。" target="_blank" rel="noopener">https://github.com/。</a><br><img src="/2018/04/12/git使用教程/register_github.png" alt="logo"><br>根据向导注册即可，不再赘述。</p>
<h2 id="3-创建仓库"><a href="#3-创建仓库" class="headerlink" title="3. 创建仓库"></a>3. 创建仓库</h2><p>登录 GitHub 后，点击导航栏中的 “+” 号，打开下拉菜单，选择 “New Repository” 新建仓库：<br><img src="/2018/04/12/git使用教程/create_repository.png" alt="logo"><br>输入新仓库名称，其它直接使用默认值，点击 “Create repository” 按钮，创建仓库。<br><img src="/2018/04/12/git使用教程/create_repository_2.png" alt="logo"><br>仓库创建成功后，可看到三种方式向仓库中添加版本库内容：<br><img src="/2018/04/12/git使用教程/create_repository_3.png" alt="logo"></p>
<h2 id="4-配置-SSH-key"><a href="#4-配置-SSH-key" class="headerlink" title="4. 配置 SSH key"></a>4. 配置 SSH key</h2><p>由于我们本地 Git 仓库和 GitHub 仓库之间的传输是通过 SSH 加密的，所以需要作一下配置。</p>
<p><strong>创建 SSH key</strong><br>在用户主目录下，查看是否有一个名为 .ssh 的文件夹，如果有，打开查看是否存在 id_rsa 和 id_rsa.pub 这两个文件，如果存在，则可以复制 id_rsa.pub 文件中的内容，然后跳过此步骤（假如文件存在，但自己从未创建过 SSH key，也可以继续进行如下步骤），如果这些都不存在，则输入如下命令：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ssh-keygen -t rsa -C &apos;your_email@youremail.com&apos;</span><br></pre></td></tr></table></figure></p>
<p>将 <a href="mailto:your_email@youremail.com" target="_blank" rel="noopener">your_email@youremail.com</a> 改为你在 GitHub 上注册的邮箱，之后会要求确认路径和输入密码，我直接使用默认的一路回车完成。成功的话会在用户主目录下生成 .ssh 文件夹，进入文件夹，使用文本工具打开 id_rsa.pub，我们可以看到文件里边一串文件信息，这是生成的 key，全选复制这些内容，以备后用。</p>
<p><strong>配置 GitHub 账户</strong><br>回到 GitHub，进入 Settings（配置）：<br><img src="/2018/04/12/git使用教程/account_setting.png" alt="logo"><br>左边选择SSH and GPG Keys，打开页面中选择 New SSH key：<br><img src="/2018/04/12/git使用教程/ssh_keys.png" alt="logo"><br>Title 随便填，Key 粘贴之前复制到剪贴板上的内容：<br><img src="/2018/04/12/git使用教程/add_ssh_key.png" alt="logo"><br>点击 Add SSH key 按钮，完成配置：<br><img src="/2018/04/12/git使用教程/add_ssh_key_ok.png" alt="logo"><br>为了验证是否成功，在 git bash 下输入：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ssh -T git@github.com</span><br></pre></td></tr></table></figure></p>
<p>如果是第一次的会提示是否 Are you sure you want to continue connecting (yes/no)? ，输入 yes 就会看到：You’ve successfully authenticated, but GitHub does not provide shell access。这就表示已成功连上 GitHub。</p>
<p><strong>远程仓库信息</strong><br>要查看远程库的详细信息，可使用 git remote –v：<br><img src="/2018/04/12/git使用教程/remote.png" alt="logo"><br>fetch 表示抓取分支，push 表示推送分支。</p>
<h2 id="5-推送本地仓库至-GitHub"><a href="#5-推送本地仓库至-GitHub" class="headerlink" title="5. 推送本地仓库至 GitHub"></a>5. 推送本地仓库至 GitHub</h2><p>我们在 GitHub 上创建仓库时，已经看到如下提示：<br><img src="/2018/04/12/git使用教程/push_an_existing_repository.png" alt="logo"><br>根据该提示，在本地 git_test 仓库下运行这两条命令：<br><img src="/2018/04/12/git使用教程/git_push.png" alt="logo"><br>输入登录 GitHub 的用户名与密码，等待本地仓库推送至 GitHub 完毕即可。<br>推送成功后，可以立刻在 GitHub 页面中看到远程库的内容已经和本地一模一样了：<br><img src="/2018/04/12/git使用教程/git_push_success.png" alt="logo"><br>以后只要在本地作了提交，就可以通过如下命令：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git push origin master</span><br></pre></td></tr></table></figure></p>
<p>把本地 master 分支的最新修改推送到 GitHub 上了。<br>现在我们就拥有了真正的分布式版本库了。</p>
<h2 id="6-抓取远程仓库分支"><a href="#6-抓取远程仓库分支" class="headerlink" title="6. 抓取远程仓库分支"></a>6. 抓取远程仓库分支</h2><p>如果是团队合作的项目，那么当有其他同事向远程仓库提交了新数据后，我们又该如何将最新版本数据从远程仓库同步到本地呢？<br>我直接在 GitHub 的仓库中添加了一个新文件 new_file.txt（内容为：this file was created on the server），来模拟其他同事的提交：<br><img src="/2018/04/12/git使用教程/new_file_on_server.png" alt="logo"><br>在更新最新版本到本地之前，我们先通过 git status 查看下本地状态，这样可以知道是否有修改过的文件没有提交，因为如果本地修改的文件没有提交而服务器中存在提交修改的版本，那么更新过程中导致更新过程中就可能产生冲突，所以通过查看状态确保本地全部提交过：<br><img src="/2018/04/12/git使用教程/git_status.png" alt="logo"><br>下面我们来更新本地仓库，使用命令：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git pull</span><br></pre></td></tr></table></figure></p>
<p><img src="/2018/04/12/git使用教程/git_pull.png" alt="logo"><br>查看本地工作区文件，可以看到服务器上的文件同步到本地仓库了：<br><img src="/2018/04/12/git使用教程/git_pull_2.png" alt="logo"><br>也可以使用 git fetch 来抓取分支，它与 git pull 的区别在于：<br>git fetch 相当于是从远程获取最新版本到本地，不会自动merge；<br>git pull 相当于是从远程获取最新版本并merge到本地。</p>
<h2 id="7-克隆远程版本库"><a href="#7-克隆远程版本库" class="headerlink" title="7. 克隆远程版本库"></a>7. 克隆远程版本库</h2><p>上面我们了解了先有本地库，后有远程库的时候，如何关联远程库。<br>现在我们想，假如先有的是远程库，要把远程库的内容克隆到本地来 如何克隆呢？<br>首先，登录 GitHub，创建一个新的仓库，名字叫 git_test_clone。如下：<br><img src="/2018/04/12/git使用教程/new_repository.png" alt="logo"><br>远程仓库准备好后，我们先复制远程仓库访问路径 URL：<br><img src="/2018/04/12/git使用教程/copy_address.png" alt="logo"><br>我先在 F 盘下新建一个文件夹 clone，将从服务器上克隆的仓库放入该文件夹下，则执行如下命令克隆仓库：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git clone URL</span><br></pre></td></tr></table></figure></p>
<p><img src="/2018/04/12/git使用教程/clone_repository.png" alt="logo"><br>克隆成功后，我们就可以进入对应目录进行本地文件编辑了。<br><img src="/2018/04/12/git使用教程/clone_success.png" alt="logo"></p>
<h1 id="九、总结"><a href="#九、总结" class="headerlink" title="九、总结"></a>九、总结</h1><p>到此，简单的 Git 使用就介绍完毕了，下面总结一下常用到的 Git 命令：<br>日常使用命令：<br><img src="/2018/04/12/git使用教程/most_use.png" alt="logo"><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br></pre></td><td class="code"><pre><span class="line"># 在当前目录新建一个Git代码库</span><br><span class="line">$ git init</span><br><span class="line"></span><br><span class="line"># 下载一个项目和它的整个代码历史</span><br><span class="line">$ git clone [url]</span><br><span class="line"></span><br><span class="line"># 显示当前的Git配置</span><br><span class="line">$ git config --list</span><br><span class="line"></span><br><span class="line"># 设置提交代码时的用户信息</span><br><span class="line">$ git config [--global] user.name &quot;[name]&quot;</span><br><span class="line">$ git config [--global] user.email &quot;[email address]&quot;</span><br><span class="line"></span><br><span class="line"># 添加指定文件到暂存区</span><br><span class="line">$ git add [file1] [file2] ...</span><br><span class="line"></span><br><span class="line"># 添加指定目录到暂存区，包括子目录</span><br><span class="line">$ git add [dir]</span><br><span class="line"></span><br><span class="line"># 添加当前目录的所有文件到暂存区</span><br><span class="line">$ git add .</span><br><span class="line"></span><br><span class="line"># 删除工作区文件，并且将这次删除放入暂存区</span><br><span class="line">$ git rm [file1] [file2] ...</span><br><span class="line"></span><br><span class="line"># 提交暂存区到仓库区</span><br><span class="line">$ git commit -m [message]</span><br><span class="line"></span><br><span class="line"># 提交暂存区的指定文件到仓库区</span><br><span class="line">$ git commit [file1] [file2] ... -m [message]</span><br><span class="line"></span><br><span class="line"># 提交工作区自上次commit之后的变化，直接到仓库区</span><br><span class="line">$ git commit -a</span><br><span class="line"></span><br><span class="line"># 提交时显示所有diff信息</span><br><span class="line">$ git commit -v</span><br><span class="line"></span><br><span class="line"># 列出所有本地分支</span><br><span class="line">$ git branch</span><br><span class="line"></span><br><span class="line"># 列出所有远程分支</span><br><span class="line">$ git branch -r</span><br><span class="line"></span><br><span class="line"># 列出所有本地分支和远程分支</span><br><span class="line">$ git branch -a</span><br><span class="line"></span><br><span class="line"># 新建一个分支，但依然停留在当前分支</span><br><span class="line">$ git branch [branch-name]</span><br><span class="line"></span><br><span class="line"># 新建一个分支，并切换到该分支</span><br><span class="line">$ git checkout -b [branch]</span><br><span class="line"></span><br><span class="line"># 切换到指定分支，并更新工作区</span><br><span class="line">$ git checkout [branch-name]</span><br><span class="line"></span><br><span class="line"># 切换到上一个分支</span><br><span class="line">$ git checkout -</span><br><span class="line"></span><br><span class="line"># 合并指定分支到当前分支</span><br><span class="line">$ git merge [branch]</span><br><span class="line"></span><br><span class="line"># 删除分支</span><br><span class="line">$ git branch -d [branch-name]</span><br><span class="line"></span><br><span class="line"># 删除远程分支</span><br><span class="line">$ git push origin --delete [branch-name]</span><br><span class="line">$ git branch -dr [remote/branch]</span><br><span class="line"></span><br><span class="line"># 显示有变更的文件</span><br><span class="line">$ git status</span><br><span class="line"></span><br><span class="line"># 显示当前分支的版本历史</span><br><span class="line">$ git log</span><br><span class="line"></span><br><span class="line"># 显示暂存区和工作区的差异</span><br><span class="line">$ git diff</span><br><span class="line"></span><br><span class="line"># 显示暂存区和上一个commit的差异</span><br><span class="line">$ git diff --cached [file]</span><br><span class="line"></span><br><span class="line"># 显示当前分支的最近几次提交</span><br><span class="line">$ git reflog</span><br><span class="line"></span><br><span class="line"># 下载远程仓库的所有变动</span><br><span class="line">$ git fetch [remote]</span><br><span class="line"></span><br><span class="line"># 显示所有远程仓库</span><br><span class="line">$ git remote -v</span><br><span class="line"></span><br><span class="line"># 取回远程仓库的变化，并与本地分支合并</span><br><span class="line">$ git pull [remote] [branch]</span><br><span class="line"></span><br><span class="line"># 上传本地指定分支到远程仓库</span><br><span class="line">$ git push [remote] [branch]</span><br><span class="line"></span><br><span class="line"># 恢复暂存区的指定文件到工作区</span><br><span class="line">$ git checkout [file]</span><br><span class="line"></span><br><span class="line"># 恢复某个commit的指定文件到暂存区和工作区</span><br><span class="line">$ git checkout [commit] [file]</span><br><span class="line"></span><br><span class="line"># 恢复暂存区的所有文件到工作区</span><br><span class="line">$ git checkout .</span><br><span class="line"></span><br><span class="line"># 重置暂存区的指定文件，与上一次commit保持一致，但工作区不变</span><br><span class="line">$ git reset [file]</span><br><span class="line"></span><br><span class="line"># 重置暂存区与工作区，与上一次commit保持一致</span><br><span class="line">$ git reset --hard</span><br><span class="line"></span><br><span class="line"># 重置当前分支的指针为指定commit，同时重置暂存区，但工作区不变</span><br><span class="line">$ git reset [commit]</span><br><span class="line"></span><br><span class="line"># 重置当前分支的HEAD为指定commit，同时重置暂存区和工作区，与指定commit一致</span><br><span class="line">$ git reset --hard [commit]</span><br></pre></td></tr></table></figure></p>
<p><strong>参考资料：</strong></p>
<p><a href="http://www.cnblogs.com/wzyxidian/p/5520002.html" target="_blank" rel="noopener">http://www.cnblogs.com/wzyxidian/p/5520002.html</a></p>
<p><a href="http://www.runoob.com/git/git-tutorial.html" target="_blank" rel="noopener">http://www.runoob.com/git/git-tutorial.html</a></p>
<p><a href="http://www.cnblogs.com/tugenhua0707/p/4050072.html" target="_blank" rel="noopener">http://www.cnblogs.com/tugenhua0707/p/4050072.html</a></p>
<p><a href="http://www.runoob.com/git/git-tutorial.html" target="_blank" rel="noopener">http://www.runoob.com/git/git-tutorial.html</a></p>
<p><a href="http://www.ruanyifeng.com/blog/2015/12/git-cheat-sheet.html" target="_blank" rel="noopener">http://www.ruanyifeng.com/blog/2015/12/git-cheat-sheet.html</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/04/12/gulp使用教程/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Du Peng">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/dupeng.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="欢迎来到我的个人技术分享博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/04/12/gulp使用教程/" itemprop="url">gulp使用教程</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-04-12T17:27:09+08:00">
                2018-04-12
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>Gulp 是前端开发过程中对代码进行构建的工具，是自动化项目的构建利器；她不仅能对网站资源进行优化，而且在开发过程中很多重复的任务能够使用正确的工具自动完成；使用她，我们不仅可以很愉快的编写代码，而且大大提高我们的工作效率。</p>
<p>Gulp 是基于 Nodejs 的自动任务运行器， 她能自动化地完成 JavaScript/coffee/sass/less/html/image/css 等文件的的测试、检查、合并、压缩、格式化、浏览器自动刷新、部署文件生成，并监听文件在改动后重复指定的这些步骤。在实现上，她借鉴了 Unix 操作系统的管道（pipe）思想，前一级的输出，直接变成后一级的输入，使得在操作上非常简单。</p>
<p>通过本文，我们将学习如何使用 Gulp 来改变开发流程，从而使开发更加快速高效。大家也可参考 Gulp 中文网 阅读 API 文档。</p>
<p>要使用 Gulp 的一个大致流程是：安装 Nodejs -&gt; 全局安装 Gulp -&gt; 项目安装 Gulp 以及 Gulp 插件 -&gt; 配置 gulpfile.js -&gt; 运行任务</p>
<h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><h2 id="安装-Nodejs"><a href="#安装-Nodejs" class="headerlink" title="安装 Nodejs"></a>安装 Nodejs</h2><p>Gulp 是基于 Nodejs 的，所以在安装 Gulp 前先安装 Nodejs。</p>
<p>进入 Nodejs 官网，会自动检测本地操作系统类型及位数，下载稳定版本的 Nodejs 安装程序。LTS 表示是稳定版本，Current 表示当前最新版本。本文下载的是 v6.9.2 LTS 版本。<br><img src="/2018/04/12/gulp使用教程/nodejs.png" alt="logo"><br>下载后根据向导安装即可。</p>
<p>安装完毕 Nodejs 后即可测试是否安装成功。在命令提示符下（通常 windows 系统是 cmd，mac 系统是终端）输入 node -v 即可查看安装的 Nodejs 版本。</p>
<p>常用命令说明：</p>
<p>node -v：查看安装的 Nodejs 版本，出现版本号，说明已正确安装nodejs。</p>
<p>npm -v：查看npm的版本号，npm是在安装 Nodejs 时一同安装的 Nodejs 包管理器。</p>
<h2 id="npm-简介"><a href="#npm-简介" class="headerlink" title="npm 简介"></a>npm 简介</h2><p>npm 是 node package manager 的简称，它是 Nodejs 的包管理器，用于 node 插件的管理，如安装、卸载、依赖管理等。<br><strong>安装插件</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install &lt;name&gt; [-g] [--save-dev]</span><br></pre></td></tr></table></figure></p>
<p><name> 表示插件名称，如 gulp。</name></p>
<p>-g 表示全局安装。全局安装可以通过命令行在任何地方调用它，本地安装（非全局安装）将安装在定位目录的 node_modules 文件夹下，通过 require() 调用。</p>
<p>–save 表示将保存配置信息至 package.json 文件，package.json 是 Nodejs 项目配置文件。之所以要保存至 package.json，是因为 Nodejs 插件包相对来说非常庞大，将配置信息写入 package.json 并将其加入版本管理，其他开发者对应下载即可（命令提示符执行 npm install，则会根据 package.json 下载所有需要的包，npm install –production 只下载 dependencies 节点的包）。</p>
<p>-dev 表示保存至 package.json 的 devDependencies 节点，不指定 -dev 将保存至 dependencies 节点；一般保存在 dependencies 的像这些：express/ejs/body-parser 等。</p>
<p><strong>卸载插件</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm uninstall &lt;name&gt; [-g] [--save-dev]</span><br></pre></td></tr></table></figure></p>
<p>要卸载插件，不要直接删除本地插件包，需要使用上述命令来卸载。</p>
<p><strong>更新插件</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm update &lt;name&gt; [-g] [--save-dev]</span><br></pre></td></tr></table></figure></p>
<p>要更新全部插件，可使用npm update [–save-dev]。</p>
<h2 id="cnpm"><a href="#cnpm" class="headerlink" title="cnpm"></a>cnpm</h2><p>npm 安装插件是从国外服务器下载资源，受网络影响大，可能出现异常，可以使用淘宝镜像，淘宝镜像是一个完整 npmjs.org 镜像，可以用它代替官方版本，其同步频率目前为 10 分钟一次以保证尽量与官方服务同步。</p>
<p>为保证安装能够正常进行，推荐使用淘宝镜像。cnpm 安装命令为:npm install -g cnpm –registry=<a href="https://registry.npm.taobao.org。" target="_blank" rel="noopener">https://registry.npm.taobao.org。</a></p>
<p>cnpm 的用法与 npm 完全一致，只需要将执行 npm 命令的地方替换为 cnpm 即可。</p>
<h2 id="全局安装-Gulp"><a href="#全局安装-Gulp" class="headerlink" title="全局安装 Gulp"></a>全局安装 Gulp</h2><p>为了在任何地方都可以使用到 Gulp 命令来执行任务，我们全局安装 Gulp，可以在命令提示符下使用 npm install gulp -g 或 cnpm install gulp -g 来实现安装。</p>
<p>等待安装结束，可使用 gulp -v 命令测试 Gulp 版本，如果看到版本号出现，则说明安装成功。本文 Gulp 版本为 3.9.1。</p>
<h2 id="生成-package-json"><a href="#生成-package-json" class="headerlink" title="生成 package.json"></a>生成 package.json</h2><p>package.json 是基于 Nodejs 项目必不可少的配置文件，它是存放在项目根目录的 json 文件。</p>
<p>package.json 用来存放即将安装的插件 name 和 version，这个文件有什么用呢？当我们把项目拷贝给别人的时候不需要拷贝插件，只需要把项目文件、package.json 和 gulpfile.js 拷贝过去就可以，接收人 cd 到项目文件目录直接输入 npm install 即可安装上我们拷贝前安装的各种插件。</p>
<p>package.json 文件格式如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;name&quot;: &quot;demo&quot;, // 项目名称</span><br><span class="line">  &quot;version&quot;: &quot;1.0.0&quot;, // 项目版本</span><br><span class="line">  &quot;description&quot;: &quot;test page&quot;, // 项目描述</span><br><span class="line">  &quot;main&quot;: &quot;example.js&quot;, // 入口文件</span><br><span class="line">  &quot;scripts&quot;: &#123; // 运行脚本命令的 npm 命令行缩写</span><br><span class="line">    &quot;test&quot;: &quot;echo \&quot;Error: no test specified\&quot; &amp;&amp; exit 1&quot;</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;author&quot;: &quot;xiaoming&quot;, // 作者</span><br><span class="line">  &quot;license&quot;: &quot;ISC&quot; // 项目许可协议</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可直接复制上述文本后修改，要注意的是 json 文件中不允许使用注释内容，所以如果是复制修改还需要将注释去掉。或在命令提示符下使用 npm init 命令来初始化自动生成 package.json 文件：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">$ npm init</span><br><span class="line">This utility will walk you through creating a package.json file.</span><br><span class="line">It only covers the most common items, and tries to guess sensible defaults.</span><br><span class="line"></span><br><span class="line">See `npm help json` for definitive documentation on these fields</span><br><span class="line">and exactly what they do.</span><br><span class="line"></span><br><span class="line">Use `npm install &lt;pkg&gt; --save` afterwards to install a package and</span><br><span class="line">save it as a dependency in the package.json file.</span><br><span class="line"></span><br><span class="line">Press ^C at any time to quit.</span><br><span class="line">name: (demo)</span><br><span class="line">version: (1.0.0)</span><br><span class="line">description: test page</span><br><span class="line">entry point: (example.js)</span><br><span class="line">test command:</span><br><span class="line">git repository:</span><br><span class="line">keywords:</span><br><span class="line">author: xiaoming</span><br><span class="line">license: (ISC)</span><br><span class="line">About to write to /Users/isaac/Documents/HTML5/projects/demo/package.json:</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">  &quot;name&quot;: &quot;demo&quot;,</span><br><span class="line">  &quot;version&quot;: &quot;1.0.0&quot;,</span><br><span class="line">  &quot;description&quot;: &quot;test page&quot;,</span><br><span class="line">  &quot;main&quot;: &quot;example.js&quot;,</span><br><span class="line">  &quot;scripts&quot;: &#123;</span><br><span class="line">    &quot;test&quot;: &quot;echo \&quot;Error: no test specified\&quot; &amp;&amp; exit 1&quot;</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;author&quot;: &quot;xiaoming&quot;,</span><br><span class="line">  &quot;license&quot;: &quot;ISC&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Is this ok? (yes) yes</span><br></pre></td></tr></table></figure></p>
<p>npm init 执行后会提示输入项目名称、版本、描述等信息，按提示输入即可，也可以留空。</p>
<h2 id="本地安装-Gulp-及-Gulp-插件"><a href="#本地安装-Gulp-及-Gulp-插件" class="headerlink" title="本地安装 Gulp 及 Gulp 插件"></a>本地安装 Gulp 及 Gulp 插件</h2><p>使用 npm install gulp –save-dev（安装了 cnpm 使用 cnpm install gulp –save-dev）在项目根目录本地安装 Gulp。</p>
<p>我们全局安装了 Gulp，又在项目目录中安装了本地 Gulp，主要因为全局安装 Gulp 是为了执行 Gulp 任务，本地安装 Gulp 则是为了调用 Gulp 插件的功能。</p>
<p>–save-dev 这个命令是将安装的插件信息写入 package.json 文件内的“devDependencies”属性内，执行后 package.json 文件内容变为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;name&quot;: &quot;demo&quot;,</span><br><span class="line">  &quot;version&quot;: &quot;1.0.0&quot;,</span><br><span class="line">  &quot;description&quot;: &quot;test page&quot;,</span><br><span class="line">  &quot;main&quot;: &quot;example.js&quot;,</span><br><span class="line">  &quot;scripts&quot;: &#123;</span><br><span class="line">    &quot;test&quot;: &quot;echo \&quot;Error: no test specified\&quot; &amp;&amp; exit 1&quot;</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;author&quot;: &quot;xiaoming&quot;,</span><br><span class="line">  &quot;license&quot;: &quot;ISC&quot;,</span><br><span class="line">  &quot;devDependencies&quot;: &#123; // 项目依赖的插件</span><br><span class="line">    &quot;gulp&quot;: &quot;^3.9.1&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>本地安装 Gulp 后，继续安装常用的 Gulp 插件，本文安装了两个插件（JS 压缩插件与 CSS 压缩插件）来作为示例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm install gulp-minify-css gulp-uglify --save-dev</span><br></pre></td></tr></table></figure></p>
<h1 id="开始使用-Gulp"><a href="#开始使用-Gulp" class="headerlink" title="开始使用 Gulp"></a>开始使用 Gulp</h1><h2 id="建立-gulpfile-js-文件"><a href="#建立-gulpfile-js-文件" class="headerlink" title="建立 gulpfile.js 文件"></a>建立 gulpfile.js 文件</h2><p>Gulp 需要一个文件作为它的主文件，在 Gulp 中这个文件叫做 gulpfile.js。</p>
<p>新建一个文件名为 gulpfile.js 的文件，然后放到项目目录中。然后在 gulpfile.js 文件中定义任务。</p>
<p>下面是一个最简单的 gulpfile.js 文件内容示例，它定义了一个默认的任务：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var gulp = require(&quot;gulp&quot;);</span><br><span class="line">gulp.task(&quot;default&quot;, function()&#123;</span><br><span class="line">	console.log(&quot;hello&quot;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<h2 id="gulp-task-方法"><a href="#gulp-task-方法" class="headerlink" title="gulp.task() 方法"></a>gulp.task() 方法</h2><p>gulp.task() 方法的主要是用来定义任务，其语法结构如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gulp.task(name[, deps], fn)</span><br></pre></td></tr></table></figure></p>
<p>参数 name 为任务名称。</p>
<p>deps 是当前定义的任务需要依赖的其他任务，为一个数组。当前定义的任务会在所有依赖的任务执行完毕后才开始执行。如果没有依赖，则可省略这个参数。</p>
<p>fn 为任务函数，我们把任务要执行的代码都写在里面。该参数也是可选的。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">var minifyCss = require(&quot;gulp-minify-css&quot;);</span><br><span class="line">gulp.task(&quot;minify-css&quot;, function()&#123;</span><br><span class="line">	gulp.src(&quot;css/*.css&quot;)</span><br><span class="line">		.pipe(minifyCss(&#123;</span><br><span class="line">			advanced:false, // 是否开启高级优化（合并选择器等）</span><br><span class="line">			compatibility:&quot;ie7&quot;, // 启用兼容模式；&apos;ie7&apos;：IE7兼容模式，&apos;ie8&apos;：IE8兼容模式，&apos;*&apos;：IE9+兼容模式</span><br><span class="line">			keepBreaks:false, // 是否保留换行</span><br><span class="line">			keepSpecialComments:&quot;*&quot; // 保留所有特殊前缀，如果不加这个参数，有可能将会删除你的部分前缀</span><br><span class="line">		&#125;))</span><br><span class="line">		.pipe(gulp.dest(&quot;dist&quot;));</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<p>上例中创建一个 CSS 压缩的任务，使用 gulp-minify-css 插件（现在 gulp-minify-css 已被废弃掉了，使用 gulp-clean-css 代替，用法基本一致）。要执行该任务，可使用任务名称来执行，使用：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ gulp minify-css</span><br></pre></td></tr></table></figure></p>
<p>再创建一个 js 压缩的任务，使用 gulp-uglify：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var uglify = require(&quot;gulp-uglify&quot;);</span><br><span class="line">gulp.task(&quot;uglify&quot;, function()&#123;</span><br><span class="line">	gulp.src([&quot;js/*.js&quot;, &quot;!js/*.min.js&quot;])</span><br><span class="line">		.pipe(uglify(&#123;</span><br><span class="line">			mangle:true, // 是否修改变量名</span><br><span class="line">			compress:true // 是否完全压缩</span><br><span class="line">		&#125;))</span><br><span class="line">		.pipe(gulp.dest(&quot;dist/js&quot;));</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<p>执行 JS 压缩任务：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ gulp uglify</span><br></pre></td></tr></table></figure></p>
<p>当然不跟任务名称，也可以使用 gulp 命令直接执行任务，默认执行的是名称为 “default” 的任务。</p>
<p>我们可以将所有任务都放到 “default” 任务中：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gulp.task(&quot;default&quot;, [&quot;minify-css&quot;, &quot;uglify&quot;]);</span><br></pre></td></tr></table></figure></p>
<p>执行：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ gulp</span><br></pre></td></tr></table></figure></p>
<p>将会调用 default 任务里的所有任务 [“minify-css”, “uglify”]。</p>
<h2 id="gulp-src-方法"><a href="#gulp-src-方法" class="headerlink" title="gulp.src() 方法"></a>gulp.src() 方法</h2><p>gulp.src() 方法是用来获取流的，这个流里的内容不是原始的文件流，而是一个虚拟文件对象流，这个虚拟文件对象中存储着原始文件的路径、文件名、内容等信息，这暂时不用去深入理解，只需简单的理解可以用这个方法来读取需要操作的文件即可。语法结构如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gulp.src(globs[, options])</span><br></pre></td></tr></table></figure></p>
<p>参数 globs 是文件匹配模式（类似正则表达式），用来匹配文件路径（包括文件名），当然这里也可以直接指定某个具体的文件路径。当有多个匹配模式时，该参数可以为一个数组。</p>
<p>options 为可选参数，通常不需要用到。</p>
<p>globs 文件匹配模式说明：<br><code>*</code> 匹配文件路径中的0个或多个字符</p>
<p><code>**</code> 匹配路径中的0个或多个目录及其子目录,需要单独出现，即它左右不能有其它东西，如果出现在末尾，也能匹配文件</p>
<p><code>?</code> 匹配文件路径中的一个字符</p>
<p><code>[...]</code> 匹配方括号中出现的字符中的任意一个，当方括号中第一个字符为^或!时，则表示不匹配方括号中出现的其他字符中的任意一个，类似 js 正则表达式中的用法</p>
<p><code>!(pattern|pattern|pattern)</code> 匹配任何与括号中给定的任一模式都不匹配的</p>
<p><code>?(pattern|pattern|pattern)</code> 匹配括号中给定的任一模式0次或1次，类似于 js 正则中的(pattern|pattern|pattern)?</p>
<p><code>+(pattern|pattern|pattern)</code> 匹配括号中给定的任一模式至少1次，类似于 js 正则中的(pattern|pattern|pattern)+</p>
<p><code>*(pattern|pattern|pattern)</code> 匹配括号中给定的任一模式0次或多次，类似于 js 正则中的(pattern|pattern|pattern)*</p>
<p><code>@(pattern|pattern|pattern)</code> 匹配括号中给定的任一模式1次，类似于 js 正则中的(pattern|pattern|pattern)</p>
<p><code>gulp.src(&quot;css/*.css&quot;)</code> 表示匹配 css 文件夹下所有后缀为 .css 的文件。</p>
<h2 id="gulp-dest-方法"><a href="#gulp-dest-方法" class="headerlink" title="gulp.dest() 方法"></a>gulp.dest() 方法</h2><p>gulp.dest() 方法是用来写文件的，可以通过管道传输。语法结构为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gulp.dest(path[, options])</span><br></pre></td></tr></table></figure></p>
<p>参数 path 为写入文件的路径，如果文件路径不存在，会自动创建。<br><code>.pipe(gulp.dest(&quot;dist&quot;))</code> 表示将生成的文件写入 dist 目录中。</p>
<p>Gulp 的使用流程一般是：先通过 gulp.src() 方法获取到我们想要处理的文件流，然后把文件流通过 pipe() 方法导入到 gulp 的插件中，最后把经过插件处理后的流再通过 pipe() 方法导入到 gulp.dest() 中，gulp.dest() 方法则把流中的内容写入到文件中。</p>
<p>我们给 gulp.dest() 传入的路径参数，只能用来指定要生成的文件的目录，而不能指定生成文件的文件名，它生成文件的文件名使用的是导入到它的文件流自身的文件名，所以生成的文件名是由导入到它的文件流决定的。</p>
<h2 id="gulp-watch-方法"><a href="#gulp-watch-方法" class="headerlink" title="gulp.watch() 方法"></a>gulp.watch() 方法</h2><p>gulp.watch 方法是用来监视文件修改的，语法结构为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">gulp.watch(glob [, opts], tasks) // 或</span><br><span class="line">gulp.watch(glob [, opts, cb])</span><br></pre></td></tr></table></figure></p>
<p>glob 表示要监视的文件匹配模式说明，通常是字符串或数组的结构；opts 参数较少使用；tasks 表示当文件发生变化时要执行的任务，该任务是通过 gulp.task() 添加的，参数数据类型为数组类型；cb 表示回调函数，会在每次改变时都被调用到。</p>
<p>使用 tasks 参数示例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var watcher = gulp.watch(&apos;js/**/*.js&apos;, [&apos;uglify&apos;,&apos;reload&apos;]);</span><br><span class="line">watcher.on(&apos;change&apos;, function(event) &#123;</span><br><span class="line">	console.log(&apos;文件路径：&apos; + event.path + &apos;，类型：&apos; + event.type);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<p>也可以使用回调函数：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">gulp.watch(&apos;js/**/*.js&apos;, function(event) &#123;</span><br><span class="line">	console.log(&apos;文件路径：&apos; + event.path + &apos;，类型：&apos; + event.type);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<p>回调函数会传递 event 参数来描述所作的改变，该 event 对象有 type 和 path 两个属性。type 描述发生改变的类型，包括：added、changed、deleted 和 renamed；path 描述触发事件的文件路径。</p>
<h1 id="常用-Gulp-插件"><a href="#常用-Gulp-插件" class="headerlink" title="常用 Gulp 插件"></a>常用 Gulp 插件</h1><p>除了 CSS 与 JS 压缩的插件外，还有其它很多常用到的 Gulp 插件，下面列举一二。</p>
<h2 id="html-文件压缩"><a href="#html-文件压缩" class="headerlink" title="html 文件压缩"></a>html 文件压缩</h2><p><a href="https://github.com/jonschlinkert/gulp-htmlmin" target="_blank" rel="noopener">gulp-htmlmin</a><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm install gulp-htmlmin --save-dev</span><br></pre></td></tr></table></figure></p>
<p>使用 gulp-minify-html 压缩 html 文件：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var gulp = require(&apos;gulp&apos;),</span><br><span class="line">	minifyHtml = require(&quot;gulp-htmlmin&quot;);</span><br><span class="line"></span><br><span class="line">gulp.task(&apos;minify-html&apos;, function()&#123;</span><br><span class="line">	gulp.src(&apos;**/*.html&apos;) // 要压缩的html文件</span><br><span class="line">		.pipe(minifyHtml(&#123;collapseWhitespace: true&#125;)) //压缩</span><br><span class="line">		.pipe(gulp.dest(&apos;dist/html&apos;));</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<h2 id="重命名"><a href="#重命名" class="headerlink" title="重命名"></a>重命名</h2><p><a href="https://github.com/hparra/gulp-rename" target="_blank" rel="noopener">gulp-rename</a><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm install gulp-rename --save-dev</span><br></pre></td></tr></table></figure></p>
<p>默认情况下，使用 gulp.dest() 方法写入文件时，文件名使用的是文件流中的文件名，如果要想改变文件名，那可以在之前用 gulp-rename 插件来改变文件流中的文件名：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">var gulp = require(&apos;gulp&apos;),</span><br><span class="line">	rename = require(&apos;gulp-rename&apos;),</span><br><span class="line">	uglify = require(&quot;gulp-uglify&quot;);</span><br><span class="line"></span><br><span class="line">gulp.task(&apos;rename&apos;, function()&#123;</span><br><span class="line">	gulp.src(&apos;js/tools.js&apos;)</span><br><span class="line">		.pipe(uglify())  // 压缩 js</span><br><span class="line">		.pipe(rename(&apos;tools.min.js&apos;)) // 将 tools.js 重命名为 tools.min.js</span><br><span class="line">		.pipe(gulp.dest(&apos;js&apos;));</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<h2 id="文件合并"><a href="#文件合并" class="headerlink" title="文件合并"></a>文件合并</h2><p><a href="https://github.com/gulp-community/gulp-concat" target="_blank" rel="noopener">gulp-concat</a><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$npm install gulp-concat --save-dev</span><br></pre></td></tr></table></figure></p>
<p>gulp-concat 可用来把多个文件合并为一个文件，我们可以用它来合并 JS 或 CSS 文件等，这样就能减少页面的 http 请求数了：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var gulp = require(&apos;gulp&apos;),</span><br><span class="line">	concat = require(&quot;gulp-concat&quot;);</span><br><span class="line"></span><br><span class="line">gulp.task(&apos;concat&apos;, function () &#123;</span><br><span class="line">	gulp.src(&apos;css/*.css&apos;)  //要合并的文件</span><br><span class="line">		.pipe(concat(&apos;style.css&apos;))  // 合并匹配到的 CSS 文件为 &quot;all.css&quot;</span><br><span class="line">		.pipe(gulp.dest(&apos;dist/css&apos;));</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<h2 id="SASS-编译"><a href="#SASS-编译" class="headerlink" title="SASS 编译"></a>SASS 编译</h2><p><a href="https://github.com/dlmanning/gulp-sass" target="_blank" rel="noopener">gulp-sass</a><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm install gulp-sass --save-dev</span><br></pre></td></tr></table></figure></p>
<p>编译 sass 文件：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">var gulp = require(&apos;gulp&apos;),</span><br><span class="line">	sass = require(&quot;gulp-sass&quot;);</span><br><span class="line">gulp.task(&quot;sass&quot;, function()&#123;</span><br><span class="line">	gulp.src(&quot;scss/*.scss&quot;)</span><br><span class="line">		.pipe(sass()) // 编译 sass</span><br><span class="line">		.pipe(minifyCss(&#123; // 压缩 CSS</span><br><span class="line">			advanced:true,</span><br><span class="line">			compatibility:&quot;ie7&quot;,</span><br><span class="line">			keepBreaks:false,</span><br><span class="line">			keepSpecialComments:&quot;*&quot;</span><br><span class="line">		&#125;))</span><br><span class="line">		.pipe(gulp.dest(&quot;dist/css&quot;));</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<p>gulp-sass 是调用 node-sass 来完成编译过程，有 node.js 环境就够了，但有的时候可能在安装 node-sass 过程中出错，只需要重新安装即可。</p>
<h2 id="自动刷新"><a href="#自动刷新" class="headerlink" title="自动刷新"></a>自动刷新</h2><p><a href="https://github.com/vohof/gulp-livereload" target="_blank" rel="noopener">gulp-livereload</a><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm install gulp-livereload --save-dev</span><br></pre></td></tr></table></figure></p>
<p>当代码发生修改变化时，它可以帮我们自动刷新页面，推荐最好配合谷歌浏览器来使用，且要安装 livereload chrome extension 扩展插件。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">var gulp = require(&quot;gulp&quot;),</span><br><span class="line">	livereload = require(&quot;gulp-livereload&quot;);</span><br><span class="line"></span><br><span class="line">gulp.task(&quot;sass&quot;, function()&#123;</span><br><span class="line">	gulp.src(&quot;scss/*.scss&quot;)</span><br><span class="line">		.pipe(sass())</span><br><span class="line">		.pipe(minifyCss(&#123;</span><br><span class="line">			advanced:true,</span><br><span class="line">			compatibility:&quot;ie7&quot;,</span><br><span class="line">			keepBreaks:false,</span><br><span class="line">			keepSpecialComments:&quot;*&quot;</span><br><span class="line">		&#125;))</span><br><span class="line">		.pipe(gulp.dest(&quot;dist/css&quot;))</span><br><span class="line">		.pipe(livereload());</span><br><span class="line">&#125;);</span><br><span class="line">gulp.task(&apos;watch&apos;, function() &#123;</span><br><span class="line">	livereload.listen(); //要在这里调用listen()方法</span><br><span class="line">	gulp.watch(&quot;scss/*.scss&quot;, [&apos;sass&apos;]);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<p>执行：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ gulp watch</span><br></pre></td></tr></table></figure></p>
<p>这样就可以实时刷新修改的 CSS 内容了</p>
<h2 id="自动处理浏览器前缀"><a href="#自动处理浏览器前缀" class="headerlink" title="自动处理浏览器前缀"></a>自动处理浏览器前缀</h2><p><a href="https://github.com/sindresorhus/gulp-autoprefixer" target="_blank" rel="noopener">gulp-autoprefixer</a><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm install gulp-autoprefixer --save-dev</span><br></pre></td></tr></table></figure></p>
<p>使用 gulp-autoprefixer 根据设置浏览器版本自动处理浏览器前缀，使用它我们可以很潇洒地写代码，不必考虑各浏览器兼容前缀。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">var autoprefixer = require(&apos;gulp-autoprefixer&apos;);</span><br><span class="line"></span><br><span class="line">gulp.task(&apos;autoFx&apos;, function () &#123;</span><br><span class="line">	gulp.src(&apos;css/style.css&apos;)</span><br><span class="line">		.pipe(autoprefixer(&#123;</span><br><span class="line">			browsers: [&apos;last 2 versions&apos;, &apos;Android &gt;= 4.0&apos;],</span><br><span class="line">			cascade: true, // 是否美化属性值</span><br><span class="line">			remove:true // 是否去掉不必要的前缀</span><br><span class="line">		&#125;))</span><br><span class="line">		.pipe(gulp.dest(&apos;dist/css&apos;));</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/04/12/hello-world/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Du Peng">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/dupeng.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="欢迎来到我的个人技术分享博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/04/12/hello-world/" itemprop="url">hexo的几个基本操作</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-04-12T14:46:08+08:00">
                2018-04-12
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  


          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="/images/dupeng.jpg"
                alt="Du Peng" />
            
              <p class="site-author-name" itemprop="name">Du Peng</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">7</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            

            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Du Peng</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Muse</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  


  











  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  

  
  
    <script type="text/javascript" src="/lib/canvas-nest/canvas-nest.min.js"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
